{"version":3,"file":"util.slice-text-block.js","sources":["../../src/utils/util.is-selection-collapsed.ts","../../src/utils/util.selection-point-to-block-offset.ts","../../src/utils/util.slice-text-block.ts"],"sourcesContent":["import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function isSelectionCollapsed(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(selection.anchor.path) ===\n      JSON.stringify(selection.focus.path) &&\n    selection.anchor.offset === selection.focus.offset\n  )\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n\n  if (selectionPoint.path.length === 1 && blockKey !== undefined) {\n    return {\n      path: [{_key: blockKey}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    context,\n    selectionPoint,\n  })\n}\n","import type {PortableTextChild, PortableTextTextBlock} from '@sanity/types'\nimport type {EditorContext} from '..'\nimport {isSpan} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport {getSelectionEndPoint} from './util.get-selection-end-point'\nimport {getSelectionStartPoint} from './util.get-selection-start-point'\n\nexport function sliceTextBlock({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'>\n  block: PortableTextTextBlock\n}): PortableTextTextBlock {\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n\n  if (!startPoint || !endPoint) {\n    return block\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (startBlockKey !== endBlockKey || startBlockKey !== block._key) {\n    return block\n  }\n\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startChildKey || !endChildKey) {\n    return block\n  }\n\n  let startChildFound = false\n  const children: Array<PortableTextChild> = []\n\n  for (const child of block.children) {\n    if (child._key === startChildKey) {\n      startChildFound = true\n\n      if (isSpan(context, child)) {\n        const text =\n          child._key === endChildKey\n            ? child.text.slice(startPoint.offset, endPoint.offset)\n            : child.text.slice(startPoint.offset)\n\n        children.push({\n          ...child,\n          text,\n        })\n      } else {\n        children.push(child)\n      }\n\n      if (startChildKey === endChildKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (child._key === endChildKey) {\n      if (isSpan(context, child)) {\n        children.push({\n          ...child,\n          text: child.text.slice(0, endPoint.offset),\n        })\n      } else {\n        children.push(child)\n      }\n\n      break\n    }\n\n    if (startChildFound) {\n      children.push(child)\n    }\n  }\n\n  return {\n    ...block,\n    children,\n  }\n}\n"],"names":["isSelectionCollapsed","selection","JSON","stringify","anchor","path","focus","offset","selectionPointToBlockOffset","context","selectionPoint","blockKey","getBlockKeyFromSelectionPoint","length","undefined","_key","childSelectionPointToBlockOffset","sliceTextBlock","block","startPoint","getSelectionStartPoint","endPoint","getSelectionEndPoint","startBlockKey","endBlockKey","startChildKey","getChildKeyFromSelectionPoint","endChildKey","startChildFound","children","child","isSpan","text","slice","push"],"mappings":";;AAKO,SAASA,qBAAqBC,WAA4B;AAC/D,SAAKA,YAKHC,KAAKC,UAAUF,UAAUG,OAAOC,IAAI,MAClCH,KAAKC,UAAUF,UAAUK,MAAMD,IAAI,KACrCJ,UAAUG,OAAOG,WAAWN,UAAUK,MAAMC,SANrC;AAQX;ACNO,SAASC,4BAA4B;AAAA,EAC1CC;AAAAA,EACAC;AAIF,GAA4B;AAC1B,QAAMC,WAAWC,8BAA8BF,cAAc;AAE7D,SAAIA,eAAeL,KAAKQ,WAAW,KAAKF,aAAaG,SAC5C;AAAA,IACLT,MAAM,CAAC;AAAA,MAACU,MAAMJ;AAAAA,IAAAA,CAAS;AAAA,IACvBJ,QAAQG,eAAeH;AAAAA,EAAAA,IAIpBS,iCAAiC;AAAA,IACtCP;AAAAA,IACAC;AAAAA,EAAAA,CACD;AACH;ACnBO,SAASO,eAAe;AAAA,EAC7BR;AAAAA,EACAS;AAIF,GAA0B;AACxB,QAAMC,aAAaC,uBAAuBX,QAAQR,SAAS,GACrDoB,WAAWC,qBAAqBb,QAAQR,SAAS;AAEvD,MAAI,CAACkB,cAAc,CAACE;AAClB,WAAOH;AAGT,QAAMK,gBAAgBX,8BAA8BO,UAAU,GACxDK,cAAcZ,8BAA8BS,QAAQ;AAE1D,MAAIE,kBAAkBC,eAAeD,kBAAkBL,MAAMH;AAC3D,WAAOG;AAGT,QAAMO,gBAAgBC,8BAA8BP,UAAU,GACxDQ,cAAcD,8BAA8BL,QAAQ;AAE1D,MAAI,CAACI,iBAAiB,CAACE;AACrB,WAAOT;AAGT,MAAIU,kBAAkB;AACtB,QAAMC,WAAqC,CAAA;AAE3C,aAAWC,SAASZ,MAAMW,UAAU;AAClC,QAAIC,MAAMf,SAASU,eAAe;AAGhC,UAFAG,kBAAkB,IAEdG,OAAOtB,SAASqB,KAAK,GAAG;AAC1B,cAAME,OACJF,MAAMf,SAASY,cACXG,MAAME,KAAKC,MAAMd,WAAWZ,QAAQc,SAASd,MAAM,IACnDuB,MAAME,KAAKC,MAAMd,WAAWZ,MAAM;AAExCsB,iBAASK,KAAK;AAAA,UACZ,GAAGJ;AAAAA,UACHE;AAAAA,QAAAA,CACD;AAAA,MAAA;AAEDH,iBAASK,KAAKJ,KAAK;AAGrB,UAAIL,kBAAkBE;AACpB;AAGF;AAAA,IAAA;AAGF,QAAIG,MAAMf,SAASY,aAAa;AAC1BI,aAAOtB,SAASqB,KAAK,IACvBD,SAASK,KAAK;AAAA,QACZ,GAAGJ;AAAAA,QACHE,MAAMF,MAAME,KAAKC,MAAM,GAAGZ,SAASd,MAAM;AAAA,MAAA,CAC1C,IAEDsB,SAASK,KAAKJ,KAAK;AAGrB;AAAA,IAAA;AAGEF,uBACFC,SAASK,KAAKJ,KAAK;AAAA,EAAA;AAIvB,SAAO;AAAA,IACL,GAAGZ;AAAAA,IACHW;AAAAA,EAAAA;AAEJ;"}