import { getBlockKeyFromSelectionPoint, getSelectionStartPoint, getSelectionEndPoint as getSelectionEndPoint$1, getChildKeyFromSelectionPoint, isTextBlock, isSpan$1 as isSpan, isSpan as isSpan$1, spanSelectionPointToBlockOffset, getBlockStartPoint, blockOffsetToSpanSelectionPoint, isListBlock } from "./util.slice-blocks.js";
import { getSelectionStartPoint as getSelectionStartPoint$1, getFocusSpan, isSelectionCollapsed, getFocusTextBlock, getPreviousInlineObject, getSelectionText, isSelectionExpanded, getFocusBlock, getFocusChild } from "./selector.is-selection-expanded.js";
import { getBlockEndPoint, isEmptyTextBlock, isEqualSelectionPoints } from "./util.is-equal-selection-points.js";
import { isKeySegment, isPortableTextSpan } from "@sanity/types";
const getSelectedBlocks = (snapshot) => {
  if (!snapshot.context.selection)
    return [];
  const selectedBlocks = [], startPoint = getSelectionStartPoint(snapshot.context.selection), endPoint = getSelectionEndPoint$1(snapshot.context.selection), startKey = getBlockKeyFromSelectionPoint(startPoint), endKey = getBlockKeyFromSelectionPoint(endPoint);
  if (!startKey || !endKey)
    return selectedBlocks;
  const startBlockIndex = snapshot.blockIndexMap.get(startKey), endBlockIndex = snapshot.blockIndexMap.get(endKey);
  if (startBlockIndex === void 0 || endBlockIndex === void 0)
    return selectedBlocks;
  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
  for (const block of slicedValue) {
    if (block._key === startKey) {
      if (selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      }), startKey === endKey)
        break;
      continue;
    }
    if (block._key === endKey) {
      selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      });
      break;
    }
    selectedBlocks.length > 0 && selectedBlocks.push({
      node: block,
      path: [{
        _key: block._key
      }]
    });
  }
  return selectedBlocks;
}, getSelectionEndPoint = (snapshot) => {
  if (snapshot.context.selection)
    return snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus;
}, getSelectedSpans = (snapshot) => {
  if (!snapshot.context.selection)
    return [];
  const selectedSpans = [], startPoint = getSelectionStartPoint$1(snapshot), endPoint = getSelectionEndPoint(snapshot);
  if (!startPoint || !endPoint)
    return selectedSpans;
  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint), endBlockKey = getBlockKeyFromSelectionPoint(endPoint), startSpanKey = getChildKeyFromSelectionPoint(startPoint), endSpanKey = getChildKeyFromSelectionPoint(endPoint);
  if (!startBlockKey || !endBlockKey)
    return selectedSpans;
  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
  if (startBlockIndex === void 0 || endBlockIndex === void 0)
    return selectedSpans;
  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
  let startBlockFound = !1;
  for (const block of slicedValue)
    if (block._key === startBlockKey && (startBlockFound = !0), !!isTextBlock(snapshot.context, block)) {
      if (block._key === startBlockKey) {
        for (const child of block.children)
          if (isSpan(snapshot.context, child)) {
            if (startSpanKey && child._key === startSpanKey) {
              if (startPoint.offset < child.text.length && selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              }), startSpanKey === endSpanKey)
                break;
              continue;
            }
            if (endSpanKey && child._key === endSpanKey) {
              endPoint.offset > 0 && selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.length > 0 && selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        if (startBlockKey === endBlockKey)
          break;
        continue;
      }
      if (block._key === endBlockKey) {
        for (const child of block.children)
          if (isSpan(snapshot.context, child)) {
            if (endSpanKey && child._key === endSpanKey) {
              endPoint.offset > 0 && selectedSpans.push({
                node: child,
                path: [{
                  _key: block._key
                }, "children", {
                  _key: child._key
                }]
              });
              break;
            }
            selectedSpans.push({
              node: child,
              path: [{
                _key: block._key
              }, "children", {
                _key: child._key
              }]
            });
          }
        break;
      }
      if (startBlockFound)
        for (const child of block.children)
          isSpan(snapshot.context, child) && selectedSpans.push({
            node: child,
            path: [{
              _key: block._key
            }, "children", {
              _key: child._key
            }]
          });
    }
  return selectedSpans;
}, getActiveAnnotations = (snapshot) => {
  if (!snapshot.context.selection)
    return [];
  const selectedBlocks = getSelectedBlocks(snapshot), selectedSpans = getSelectedSpans(snapshot), focusSpan = getFocusSpan(snapshot);
  if (selectedSpans.length === 0 || !focusSpan)
    return [];
  if (selectedSpans.length === 1 && isSelectionCollapsed(snapshot)) {
    if (snapshot.context.selection.focus.offset === 0)
      return [];
    if (snapshot.context.selection.focus.offset === focusSpan.node.text.length)
      return [];
  }
  const activeAnnotations = snapshot.beta.activeAnnotations;
  return selectedBlocks.flatMap((block) => isTextBlock(snapshot.context, block.node) ? block.node.markDefs ?? [] : []).filter((markDef) => activeAnnotations.includes(markDef._key));
}, getActiveListItem = (snapshot) => {
  if (!snapshot.context.selection)
    return;
  const selectedTextBlocks = getSelectedBlocks(snapshot).map((block) => block.node).filter((block) => isTextBlock(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstListItem = firstTextBlock.listItem;
  if (firstListItem && selectedTextBlocks.every((block) => block.listItem === firstListItem))
    return firstListItem;
}, getActiveStyle = (snapshot) => {
  if (!snapshot.context.selection)
    return;
  const selectedTextBlocks = getSelectedBlocks(snapshot).map((block) => block.node).filter((block) => isTextBlock(snapshot.context, block)), firstTextBlock = selectedTextBlocks.at(0);
  if (!firstTextBlock)
    return;
  const firstStyle = firstTextBlock.style;
  if (firstStyle && selectedTextBlocks.every((block) => block.style === firstStyle))
    return firstStyle;
}, getNextInlineObject = (snapshot) => {
  const focusTextBlock = getFocusTextBlock(snapshot), selectionEndPoint = getSelectionEndPoint(snapshot), selectionEndPointChildKey = selectionEndPoint && isKeySegment(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;
  if (!focusTextBlock || !selectionEndPointChildKey)
    return;
  let endPointChildFound = !1, inlineObject;
  for (const child of focusTextBlock.node.children) {
    if (child._key === selectionEndPointChildKey) {
      endPointChildFound = !0;
      continue;
    }
    if (!isSpan$1(snapshot.context, child) && endPointChildFound) {
      inlineObject = {
        node: child,
        path: [...focusTextBlock.path, "children", {
          _key: child._key
        }]
      };
      break;
    }
  }
  return inlineObject;
}, getCaretWordSelection = (snapshot) => {
  if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))
    return null;
  const focusTextBlock = getFocusTextBlock(snapshot), selectionStartPoint = getSelectionStartPoint$1(snapshot), selectionStartOffset = selectionStartPoint ? spanSelectionPointToBlockOffset({
    context: snapshot.context,
    selectionPoint: selectionStartPoint
  }) : void 0;
  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset)
    return null;
  const previousInlineObject = getPreviousInlineObject(snapshot), blockStartPoint = getBlockStartPoint({
    context: snapshot.context,
    block: focusTextBlock
  }), textDirectlyBefore = getSelectionText({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: {
        anchor: previousInlineObject ? {
          path: previousInlineObject.path,
          offset: 0
        } : blockStartPoint,
        focus: selectionStartPoint
      }
    }
  }).split(/\s+/).at(-1), nextInlineObject = getNextInlineObject(snapshot), blockEndPoint = getBlockEndPoint({
    context: snapshot.context,
    block: focusTextBlock
  }), textDirectlyAfter = getSelectionText({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: {
        anchor: selectionStartPoint,
        focus: nextInlineObject ? {
          path: nextInlineObject.path,
          offset: 0
        } : blockEndPoint
      }
    }
  }).split(/\s+/).at(0);
  if ((textDirectlyBefore === void 0 || textDirectlyBefore === "") && (textDirectlyAfter === void 0 || textDirectlyAfter === ""))
    return null;
  const caretWordStartOffset = textDirectlyBefore ? {
    ...selectionStartOffset,
    offset: selectionStartOffset.offset - textDirectlyBefore.length
  } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {
    ...selectionStartOffset,
    offset: selectionStartOffset.offset + textDirectlyAfter.length
  } : selectionStartOffset, caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({
    context: snapshot.context,
    blockOffset: caretWordStartOffset,
    direction: "backward"
  }), caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({
    context: snapshot.context,
    blockOffset: caretWordEndOffset,
    direction: "forward"
  });
  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint)
    return null;
  const caretWordSelection = {
    anchor: caretWordStartSelectionPoint,
    focus: caretWordEndSelectionPoint
  };
  return isSelectionExpanded({
    context: {
      ...snapshot.context,
      selection: caretWordSelection
    }
  }) ? caretWordSelection : null;
}, getFirstBlock = (snapshot) => {
  const node = snapshot.context.value[0];
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getFocusBlockObject = (snapshot) => {
  const focusBlock = getFocusBlock(snapshot);
  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusInlineObject = (snapshot) => {
  const focusChild = getFocusChild(snapshot);
  return focusChild && !isPortableTextSpan(focusChild.node) ? {
    node: focusChild.node,
    path: focusChild.path
  } : void 0;
}, getFocusListBlock = (snapshot) => {
  const focusTextBlock = getFocusTextBlock(snapshot);
  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node) ? {
    node: focusTextBlock.node,
    path: focusTextBlock.path
  } : void 0;
}, getLastBlock = (snapshot) => {
  const node = snapshot.context.value[snapshot.context.value.length - 1] ? snapshot.context.value[snapshot.context.value.length - 1] : void 0;
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getSelectionEndBlock = (snapshot) => {
  const endPoint = getSelectionEndPoint$1(snapshot.context.selection);
  if (endPoint)
    return getFocusBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: endPoint,
          focus: endPoint
        }
      }
    });
}, getNextBlock = (snapshot) => {
  const selectionEndBlock = getSelectionEndBlock(snapshot);
  if (!selectionEndBlock)
    return;
  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key);
  if (index === void 0 || index === snapshot.context.value.length - 1)
    return;
  const nextBlock = snapshot.context.value.at(index + 1);
  return nextBlock ? {
    node: nextBlock,
    path: [{
      _key: nextBlock._key
    }]
  } : void 0;
}, getSelectionStartBlock = (snapshot) => {
  const startPoint = getSelectionStartPoint(snapshot.context.selection);
  if (startPoint)
    return getFocusBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: startPoint,
          focus: startPoint
        }
      }
    });
}, getPreviousBlock = (snapshot) => {
  const selectionStartBlock = getSelectionStartBlock(snapshot);
  if (!selectionStartBlock)
    return;
  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key);
  if (index === void 0 || index === 0)
    return;
  const previousBlock = snapshot.context.value.at(index - 1);
  return previousBlock ? {
    node: previousBlock,
    path: [{
      _key: previousBlock._key
    }]
  } : void 0;
}, getSelectedTextBlocks = (snapshot) => {
  if (!snapshot.context.selection)
    return [];
  const selectedTextBlocks = [], startPoint = getSelectionStartPoint(snapshot.context.selection), endPoint = getSelectionEndPoint$1(snapshot.context.selection), startBlockKey = getBlockKeyFromSelectionPoint(startPoint), endBlockKey = getBlockKeyFromSelectionPoint(endPoint);
  if (!startBlockKey || !endBlockKey)
    return selectedTextBlocks;
  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
  if (startBlockIndex === void 0 || endBlockIndex === void 0)
    return selectedTextBlocks;
  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
  for (const block of slicedValue) {
    if (block._key === startBlockKey) {
      if (isTextBlock(snapshot.context, block) && selectedTextBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      }), startBlockKey === endBlockKey)
        break;
      continue;
    }
    if (block._key === endBlockKey) {
      isTextBlock(snapshot.context, block) && selectedTextBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      });
      break;
    }
    selectedTextBlocks.length > 0 && isTextBlock(snapshot.context, block) && selectedTextBlocks.push({
      node: block,
      path: [{
        _key: block._key
      }]
    });
  }
  return selectedTextBlocks;
}, getTrimmedSelection = (snapshot) => {
  if (!snapshot.context.selection)
    return snapshot.context.selection;
  const startPoint = getSelectionStartPoint(snapshot.context.selection), endPoint = getSelectionEndPoint$1(snapshot.context.selection), startBlockKey = getBlockKeyFromSelectionPoint(startPoint), startChildKey = getChildKeyFromSelectionPoint(startPoint), endBlockKey = getBlockKeyFromSelectionPoint(endPoint), endChildKey = getChildKeyFromSelectionPoint(endPoint);
  if (!startBlockKey || !endBlockKey)
    return snapshot.context.selection;
  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
  if (startBlockIndex === void 0 || endBlockIndex === void 0)
    return snapshot.context.selection;
  const slicedValue = snapshot.context.value.slice(startBlockIndex, endBlockIndex + 1);
  let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;
  for (const block of slicedValue)
    if (!(block._key === startBlockKey && (startBlockFound = !0, isTextBlock(snapshot.context, block) && isEmptyTextBlock(snapshot.context, block))) && startBlockFound && isTextBlock(snapshot.context, block)) {
      if (block._key === endBlockKey && isEmptyTextBlock(snapshot.context, block))
        break;
      for (const child of block.children) {
        if (child._key === endChildKey && (!isSpan(snapshot.context, child) || endPoint.offset === 0)) {
          adjustedEndPoint = previousPotentialEndpoint ? {
            path: [{
              _key: previousPotentialEndpoint.blockKey
            }, "children", {
              _key: previousPotentialEndpoint.span._key
            }],
            offset: previousPotentialEndpoint.span.text.length
          } : void 0, trimEndPoint = !0;
          break;
        }
        if (trimStartPoint) {
          const lonelySpan = isSpan(snapshot.context, child) && block.children.length === 1;
          (isSpan(snapshot.context, child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {
            path: [{
              _key: block._key
            }, "children", {
              _key: child._key
            }],
            offset: 0
          }, previousPotentialEndpoint = {
            blockKey: block._key,
            span: child
          }, trimStartPoint = !1);
          continue;
        }
        if (child._key === startChildKey) {
          if (!isSpan(snapshot.context, child)) {
            trimStartPoint = !0;
            continue;
          }
          if (startPoint.offset === child.text.length) {
            trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {
              blockKey: block._key,
              span: child
            } : previousPotentialEndpoint;
            continue;
          }
        }
        previousPotentialEndpoint = isSpan(snapshot.context, child) && child.text.length > 0 ? {
          blockKey: block._key,
          span: child
        } : previousPotentialEndpoint;
      }
      if (block._key === endBlockKey)
        break;
    }
  const trimmedSelection = snapshot.context.selection.backward ? {
    anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,
    focus: adjustedStartPoint ?? startPoint,
    backward: !0
  } : {
    anchor: adjustedStartPoint ?? startPoint,
    focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint
  };
  if (isSelectionCollapsed({
    context: {
      ...snapshot.context,
      selection: trimmedSelection
    }
  })) {
    const focusTextBlock = getFocusTextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: trimmedSelection
      }
    });
    if (focusTextBlock && !isEmptyTextBlock(snapshot.context, focusTextBlock.node))
      return null;
  }
  return trimmedSelection;
};
function isActiveAnnotation(annotation) {
  return (snapshot) => getSelectedBlocks(snapshot).flatMap((block) => isTextBlock(snapshot.context, block.node) ? block.node.markDefs ?? [] : []).filter((markDef) => markDef._type === annotation && snapshot.beta.activeAnnotations.includes(markDef._key)).length > 0;
}
function isActiveDecorator(decorator) {
  return (snapshot) => {
    if (isSelectionExpanded(snapshot)) {
      const selectedSpans = getSelectedSpans(snapshot);
      return selectedSpans.length > 0 && selectedSpans.every((span) => span.node.marks?.includes(decorator));
    }
    return snapshot.beta.activeDecorators.includes(decorator);
  };
}
function isActiveListItem(listItem) {
  return (snapshot) => getActiveListItem(snapshot) === listItem;
}
function isActiveStyle(style) {
  return (snapshot) => getActiveStyle(snapshot) === style;
}
function isAtTheEndOfBlock(block) {
  return (snapshot) => {
    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))
      return !1;
    const blockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block
    });
    return isEqualSelectionPoints(snapshot.context.selection.focus, blockEndPoint);
  };
}
function isAtTheStartOfBlock(block) {
  return (snapshot) => {
    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot))
      return !1;
    const blockStartPoint = getBlockStartPoint({
      context: snapshot.context,
      block
    });
    return isEqualSelectionPoints(snapshot.context.selection.focus, blockStartPoint);
  };
}
function isPointAfterSelection(point) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const endPoint = getSelectionEndPoint$1(snapshot.context.selection), endBlockKey = getBlockKeyFromSelectionPoint(endPoint), endChildKey = getChildKeyFromSelectionPoint(endPoint), pointBlockKey = getBlockKeyFromSelectionPoint(point), pointChildKey = getChildKeyFromSelectionPoint(point);
    if (!pointBlockKey || !endBlockKey)
      return !1;
    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey), endBlockIndex = snapshot.blockIndexMap.get(endBlockKey);
    if (pointBlockIndex === void 0 || endBlockIndex === void 0)
      return !1;
    if (pointBlockIndex > endBlockIndex)
      return !0;
    if (pointBlockIndex < endBlockIndex)
      return !1;
    const pointBlock = snapshot.context.value.at(pointBlockIndex);
    if (!pointBlock || !isTextBlock(snapshot.context, pointBlock))
      return !1;
    let pointChildIndex, endChildIndex, childIndex = -1;
    for (const child of pointBlock.children) {
      if (childIndex++, child._key === pointChildKey && child._key === endChildKey)
        return point.offset > endPoint.offset;
      if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === endChildKey && (endChildIndex = childIndex), pointChildIndex !== void 0 && endChildIndex !== void 0)
        break;
    }
    return pointChildIndex === void 0 || endChildIndex === void 0 ? !1 : pointChildIndex > endChildIndex;
  };
}
function isPointBeforeSelection(point) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const startPoint = getSelectionStartPoint(snapshot.context.selection), startBlockKey = getBlockKeyFromSelectionPoint(startPoint), startChildKey = getChildKeyFromSelectionPoint(startPoint), pointBlockKey = getBlockKeyFromSelectionPoint(point), pointChildKey = getChildKeyFromSelectionPoint(point);
    if (!pointBlockKey || !startBlockKey)
      return !1;
    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey), pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey);
    if (startBlockIndex === void 0 || pointBlockIndex === void 0)
      return !1;
    if (pointBlockIndex < startBlockIndex)
      return !0;
    if (pointBlockIndex > startBlockIndex)
      return !1;
    const pointBlock = snapshot.context.value.at(pointBlockIndex);
    if (!pointBlock || !isTextBlock(snapshot.context, pointBlock))
      return !1;
    let pointChildIndex, startChildIndex, childIndex = -1;
    for (const child of pointBlock.children) {
      if (childIndex++, child._key === pointChildKey && child._key === startChildKey)
        return point.offset < startPoint.offset;
      if (child._key === pointChildKey && (pointChildIndex = childIndex), child._key === startChildKey && (startChildIndex = childIndex), pointChildIndex !== void 0 && startChildIndex !== void 0)
        break;
    }
    return pointChildIndex === void 0 || startChildIndex === void 0 ? !1 : pointChildIndex < startChildIndex;
  };
}
function isOverlappingSelection(selection) {
  return (snapshot) => {
    if (!selection || !snapshot.context.selection)
      return !1;
    const selectionStartPoint = getSelectionStartPoint$1({
      context: {
        ...snapshot.context,
        selection
      }
    }), selectionEndPoint = getSelectionEndPoint({
      context: {
        ...snapshot.context,
        selection
      }
    }), originalSelectionStartPoint = getSelectionStartPoint$1(snapshot), originalSelectionEndPoint = getSelectionEndPoint(snapshot);
    if (!selectionStartPoint || !selectionEndPoint || !originalSelectionStartPoint || !originalSelectionEndPoint)
      return !1;
    const startPointBeforeSelection = isPointBeforeSelection(selectionStartPoint)(snapshot), startPointAfterSelection = isPointAfterSelection(selectionStartPoint)(snapshot), endPointBeforeSelection = isPointBeforeSelection(selectionEndPoint)(snapshot), endPointAfterSelection = isPointAfterSelection(selectionEndPoint)(snapshot), originalStartPointBeforeStartPoint = isPointBeforeSelection(originalSelectionStartPoint)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionStartPoint,
          focus: selectionStartPoint
        }
      }
    }), originalStartPointAfterStartPoint = isPointAfterSelection(originalSelectionStartPoint)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionStartPoint,
          focus: selectionStartPoint
        }
      }
    }), originalEndPointBeforeEndPoint = isPointBeforeSelection(originalSelectionEndPoint)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionEndPoint,
          focus: selectionEndPoint
        }
      }
    }), originalEndPointAfterEndPoint = isPointAfterSelection(originalSelectionEndPoint)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionEndPoint,
          focus: selectionEndPoint
        }
      }
    }), endPointEqualToOriginalStartPoint = isEqualSelectionPoints(selectionEndPoint, originalSelectionStartPoint), startPointEqualToOriginalEndPoint = isEqualSelectionPoints(selectionStartPoint, originalSelectionEndPoint);
    return endPointBeforeSelection && !endPointEqualToOriginalStartPoint || startPointAfterSelection && !startPointEqualToOriginalEndPoint ? !1 : !originalStartPointBeforeStartPoint && originalStartPointAfterStartPoint && !originalEndPointBeforeEndPoint && originalEndPointAfterEndPoint ? !endPointEqualToOriginalStartPoint : originalStartPointBeforeStartPoint && !originalStartPointAfterStartPoint && originalEndPointBeforeEndPoint && !originalEndPointAfterEndPoint ? !startPointEqualToOriginalEndPoint : !startPointAfterSelection || !startPointBeforeSelection || !endPointAfterSelection || !endPointBeforeSelection;
  };
}
const isSelectingEntireBlocks = (snapshot) => {
  if (!snapshot.context.selection)
    return !1;
  const startPoint = snapshot.context.selection.backward ? snapshot.context.selection.focus : snapshot.context.selection.anchor, endPoint = snapshot.context.selection.backward ? snapshot.context.selection.anchor : snapshot.context.selection.focus, startBlock = getSelectionStartBlock(snapshot), endBlock = getSelectionEndBlock(snapshot);
  if (!startBlock || !endBlock)
    return !1;
  const startBlockStartPoint = getBlockStartPoint({
    context: snapshot.context,
    block: startBlock
  }), endBlockEndPoint = getBlockEndPoint({
    context: snapshot.context,
    block: endBlock
  });
  return isEqualSelectionPoints(startBlockStartPoint, startPoint) && isEqualSelectionPoints(endBlockEndPoint, endPoint);
};
export {
  getActiveAnnotations,
  getActiveListItem,
  getActiveStyle,
  getCaretWordSelection,
  getFirstBlock,
  getFocusBlockObject,
  getFocusInlineObject,
  getFocusListBlock,
  getLastBlock,
  getNextBlock,
  getNextInlineObject,
  getPreviousBlock,
  getSelectedBlocks,
  getSelectedSpans,
  getSelectedTextBlocks,
  getSelectionEndBlock,
  getSelectionEndPoint,
  getSelectionStartBlock,
  getTrimmedSelection,
  isActiveAnnotation,
  isActiveDecorator,
  isActiveListItem,
  isActiveStyle,
  isAtTheEndOfBlock,
  isAtTheStartOfBlock,
  isOverlappingSelection,
  isPointAfterSelection,
  isPointBeforeSelection,
  isSelectingEntireBlocks
};
//# sourceMappingURL=selector.is-selecting-entire-blocks.js.map
