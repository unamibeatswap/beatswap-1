{"version":3,"file":"selector.is-selecting-entire-blocks.cjs","sources":["../../src/selectors/selector.get-selected-blocks.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-first-block.ts","../../src/selectors/selector.get-focus-block-object.ts","../../src/selectors/selector.get-focus-inline-object.ts","../../src/selectors/selector.get-focus-list-block.ts","../../src/selectors/selector.get-last-block.ts","../../src/selectors/selector.get-selection-end-block.ts","../../src/selectors/selector.get-next-block.ts","../../src/selectors/selector.get-selection-start-block.ts","../../src/selectors/selector.get-previous-block.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-trimmed-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: BlockPath}> = []\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n","import type {EditorSelectionPoint} from '..'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return selectedSpans\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const startSpanKey = getChildKeyFromSelectionPoint(startPoint)\n  const endSpanKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedSpans\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  let startBlockFound = false\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getFocusSpan} from './selector.get-focus-span'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n  const focusSpan = getFocusSpan(snapshot)\n\n  if (selectedSpans.length === 0 || !focusSpan) {\n    return []\n  }\n\n  if (selectedSpans.length === 1 && isSelectionCollapsed(snapshot)) {\n    if (snapshot.context.selection.focus.offset === 0) {\n      return []\n    }\n    if (\n      snapshot.context.selection.focus.offset === focusSpan.node.text.length\n    ) {\n      return []\n    }\n  }\n\n  const activeAnnotations = snapshot.beta.activeAnnotations\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {isKeySegment, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isSpan} from '../utils'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils/util.block-offset'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import {isPortableTextSpan, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  {node: PortableTextObject; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isListBlock} from '../internal-utils/parse-blocks'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key)\n\n  if (index === undefined || index === snapshot.context.value.length - 1) {\n    return undefined\n  }\n\n  const nextBlock = snapshot.context.value.at(index + 1)\n\n  return nextBlock\n    ? {node: nextBlock, path: [{_key: nextBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key)\n\n  if (index === undefined || index === 0) {\n    return undefined\n  }\n\n  const previousBlock = snapshot.context.value.at(index - 1)\n\n  return previousBlock\n    ? {node: previousBlock, path: [{_key: previousBlock._key}]}\n    : undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getBlockKeyFromSelectionPoint} from '../selection/selection-point'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint, getSelectionStartPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: BlockPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedTextBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextSpan} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan, isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {\n  getSelectionEndPoint,\n  getSelectionStartPoint,\n  isEmptyTextBlock,\n} from '../utils'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return snapshot.context.selection\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return snapshot.context.selection\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return snapshot.context.selection\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (\n        isTextBlock(snapshot.context, block) &&\n        isEmptyTextBlock(snapshot.context, block)\n      ) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (\n      block._key === endBlockKey &&\n      isEmptyTextBlock(snapshot.context, block)\n    ) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isSpan(snapshot.context, child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isSpan(snapshot.context, child) && block.children.length === 1\n\n        if (\n          (isSpan(snapshot.context, child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isSpan(snapshot.context, child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isSpan(snapshot.context, child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = snapshot.context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (\n      focusTextBlock &&\n      !isEmptyTextBlock(snapshot.context, focusTextBlock.node)\n    ) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        snapshot.beta.activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.beta.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return utils.isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionEndPoint} from '../utils'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const endPoint = getSelectionEndPoint(snapshot.context.selection)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n    const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n    if (pointBlockIndex === undefined || endBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex > endBlockIndex) {\n      // The point block is after the end block.\n      return true\n    }\n\n    if (pointBlockIndex < endBlockIndex) {\n      // The point block is before the end block.\n      return false\n    }\n\n    // The point block is the same as the end block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the end block, the point is not\n      // after the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let endChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the end block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === endChildKey) {\n        return point.offset > endPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === endChildKey) {\n        endChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && endChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || endChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex > endChildIndex\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isTextBlock} from '../internal-utils/parse-blocks'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../selection/selection-point'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionStartPoint} from '../utils'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const startPoint = getSelectionStartPoint(snapshot.context.selection)\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n\n    if (startBlockIndex === undefined || pointBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex < startBlockIndex) {\n      // The point block is before the start block.\n      return true\n    }\n\n    if (pointBlockIndex > startBlockIndex) {\n      // The point block is after the start block.\n      return false\n    }\n\n    // The point block is the same as the start block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the start block, the point is not\n      // before the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let startChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the start block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === startChildKey) {\n        return point.offset < startPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === startChildKey) {\n        startChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && startChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || startChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex < startChildIndex\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = utils.getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = utils.getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    utils.isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    utils.isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["getSelectedBlocks","snapshot","context","selection","selectedBlocks","startPoint","getSelectionStartPoint","endPoint","getSelectionEndPoint","startKey","getBlockKeyFromSelectionPoint","endKey","startBlockIndex","blockIndexMap","get","endBlockIndex","undefined","slicedValue","value","slice","block","_key","push","node","path","length","backward","anchor","focus","getSelectedSpans","selectedSpans","startBlockKey","endBlockKey","startSpanKey","getChildKeyFromSelectionPoint","endSpanKey","startBlockFound","isTextBlock","child","children","isSpan","offset","text","getActiveAnnotations","focusSpan","getFocusSpan","isSelectionCollapsed","activeAnnotations","beta","flatMap","markDefs","filter","markDef","includes","getActiveListItem","selectedTextBlocks","map","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getNextInlineObject","focusTextBlock","getFocusTextBlock","selectionEndPoint","selectionEndPointChildKey","isKeySegment","endPointChildFound","inlineObject","getCaretWordSelection","selectionStartPoint","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","getPreviousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","getSelectionText","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","caretWordEndSelectionPoint","caretWordSelection","isSelectionExpanded","getFirstBlock","getFocusBlockObject","focusBlock","getFocusBlock","getFocusInlineObject","focusChild","getFocusChild","isPortableTextSpan","getFocusListBlock","isListBlock","getLastBlock","getSelectionEndBlock","getNextBlock","selectionEndBlock","index","nextBlock","getSelectionStartBlock","getPreviousBlock","selectionStartBlock","previousBlock","getSelectedTextBlocks","getTrimmedSelection","startChildKey","endChildKey","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","isEmptyTextBlock","blockKey","span","lonelySpan","trimmedSelection","isActiveAnnotation","annotation","_type","isActiveDecorator","decorator","marks","activeDecorators","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","utils","isAtTheStartOfBlock","isPointAfterSelection","point","pointBlockKey","pointChildKey","pointBlockIndex","pointBlock","pointChildIndex","endChildIndex","childIndex","isPointBeforeSelection","startChildIndex","isOverlappingSelection","originalSelectionStartPoint","originalSelectionEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","endPointEqualToOriginalStartPoint","isEqualSelectionPoints","startPointEqualToOriginalEndPoint","isSelectingEntireBlocks","startBlock","endBlock","startBlockStartPoint","endBlockEndPoint"],"mappings":"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"}