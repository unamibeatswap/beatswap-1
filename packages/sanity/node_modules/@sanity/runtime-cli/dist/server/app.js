import { existsSync, readFileSync, watchFile } from 'node:fs';
import * as http from 'node:http';
import { default as mime } from 'mime-types';
import { WebSocketServer } from 'ws';
import { readLocalBlueprint } from '../actions/blueprints/blueprint.js';
import config from '../config.js';
import { findFunctionByName } from '../utils/find-function.js';
import invoke from '../utils/invoke-local.js';
import { isRecord } from '../utils/is-record.js';
const host = 'localhost';
const app = (port) => {
    const requestListener = async (req, res) => {
        res.setHeader('Content-Type', 'application/json');
        switch (true) {
            case req.url === '/blueprint': {
                try {
                    const { parsedBlueprint, projectId } = await readLocalBlueprint();
                    res.setHeader('Content-Type', 'application/json');
                    res.writeHead(200);
                    res.end(JSON.stringify({ parsedBlueprint, projectId })); // Use blueprint directly
                }
                catch (error) {
                    res.writeHead(404);
                    res.end(JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }));
                }
                break;
            }
            case req.url === '/invoke': {
                if (req.method === 'POST') {
                    const body = [];
                    req.on('data', (data) => body.push(data));
                    req.on('end', async () => {
                        res.setHeader('Content-Type', 'application/json');
                        try {
                            const { data, func: functionName } = parseInvokeRequest(Buffer.concat(body));
                            const { context, event } = data;
                            const start = performance.now();
                            const { parsedBlueprint } = await readLocalBlueprint();
                            const resource = findFunctionByName(parsedBlueprint, functionName);
                            const readBlueprintTime = performance.now() - start;
                            const response = await invoke(resource, event, context, { forceColor: false });
                            const timings = { ...response.timings, 'blueprint:read': readBlueprintTime };
                            const timingHeaders = [];
                            for (const [key, value] of Object.entries(timings)) {
                                timingHeaders.push(`${key.replace(/:/g, '-')};dur=${Math.abs(value).toFixed(1)}`);
                            }
                            if (timingHeaders.length > 0) {
                                res.setHeader('Server-Timing', timingHeaders.join(', '));
                            }
                            res.end(JSON.stringify(response));
                        }
                        catch (error) {
                            console.error(error);
                            const response = { logs: '', error: '' };
                            if (error instanceof Error) {
                                response.logs = error.message;
                            }
                            res.writeHead(200);
                            res.end(JSON.stringify(response));
                        }
                    });
                }
                break;
            }
            case req.url === '/projects': {
                res.setHeader('Content-Type', 'application/json');
                try {
                    const response = await fetch(`${config.apiUrl}/v2021-06-07/projects?includeOrganizationProjects=true`, {
                        headers: {
                            Authorization: `Bearer ${config.token}`,
                        },
                    });
                    const json = await response.json();
                    res.writeHead(200);
                    res.end(JSON.stringify(json));
                }
                catch (error) {
                    res.writeHead(200);
                    res.end(JSON.stringify([]));
                }
                break;
            }
            case req.url?.startsWith('/datasets'): {
                const url = req.url || '';
                const matches = url.match(/[?&]project=([^&]+)/) || [];
                const projectId = matches ? matches[1] : null;
                res.setHeader('Content-Type', 'application/json');
                try {
                    let json = [];
                    if (projectId) {
                        const response = await fetch(`${config.apiUrl}/v2024-08-25/projects/${projectId}/datasets?includeStats=true`, {
                            headers: {
                                Authorization: `Bearer ${config.token}`,
                            },
                        });
                        json = await response.json();
                    }
                    res.writeHead(200);
                    res.end(JSON.stringify(json));
                }
                catch (error) {
                    res.writeHead(200);
                    res.end(JSON.stringify([]));
                }
                break;
            }
            default: {
                const requestPath = req.url?.endsWith('/') ? `${req.url}index.html` : req.url;
                const filePath = new URL(`./static${requestPath}`, import.meta.url).pathname;
                if (existsSync(filePath)) {
                    const mimeType = mime.lookup(filePath) || 'text/plain';
                    res.setHeader('Content-Type', mimeType);
                    const content = readFileSync(filePath).toString();
                    res.writeHead(200);
                    res.end(content);
                }
                else {
                    res.writeHead(404);
                    res.end();
                }
                break;
            }
        }
    };
    const server = http.createServer(requestListener);
    server.listen(port, host, () => { });
    const wss = new WebSocketServer({ port: 8974 });
    wss.on('connection', async function connection(ws) {
        ws.on('error', console.error);
        const { fileInfo } = await readLocalBlueprint();
        watchFile(fileInfo.blueprintFilePath, { interval: 2007 }, async () => {
            ws.send('reload-blueprint');
        });
    });
};
function parseInvokeRequest(body) {
    let json;
    try {
        json = JSON.parse(body.toString('utf8'));
    }
    catch (error) {
        throw new Error('Request body is not valid JSON', { cause: error });
    }
    if (!isRecord(json)) {
        throw new Error('Request body is not valid, must be an object');
    }
    if (!('func' in json)) {
        throw new Error('Request body is not valid, missing `func` field');
    }
    if (!('data' in json)) {
        throw new Error('Request body is not valid, missing `data` field');
    }
    const { data, func } = json;
    if (typeof func !== 'string') {
        throw new Error('Request body is not valid, `func` field is not a string');
    }
    if (!isRecord(data)) {
        throw new Error('Request body is not valid, `data` field is not an object');
    }
    const { context, event } = data;
    if (!isRecord(context)) {
        throw new Error('Request body is not valid, `context` field is not an object');
    }
    if (!isRecord(event)) {
        throw new Error('Request body is not valid, `event` field is not an object');
    }
    if (!('clientOptions' in context)) {
        throw new Error('Request body is not valid, `context.clientOptions` field is missing');
    }
    if (!isRecord(context.clientOptions)) {
        throw new Error('Request body is not valid, `context.clientOptions` field is not an object');
    }
    const { projectId, dataset, apiVersion } = context.clientOptions;
    if (typeof projectId !== 'string' && typeof projectId !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.projectId` field is not a string');
    }
    if (typeof dataset !== 'string' && typeof dataset !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.dataset` field is not a string');
    }
    if (typeof apiVersion !== 'string' && typeof apiVersion !== 'undefined') {
        throw new Error('Request body is not valid, `context.clientOptions.apiVersion` field is not a string');
    }
    const clientOptions = {
        ...context.clientOptions,
        projectId,
        dataset,
        // Prefer `undefined` over empty string, triggering the right warnings in the client
        apiVersion: apiVersion || undefined,
    };
    return { func, data: { context: { ...context, clientOptions }, event } };
}
export default app;
