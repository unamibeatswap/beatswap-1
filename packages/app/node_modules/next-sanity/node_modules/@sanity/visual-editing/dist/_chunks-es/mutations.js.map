{"version":3,"file":"mutations.js","sources":["../../../../node_modules/.pnpm/@sanity+types@3.88.0_@types+react@19.1.6_debug@4.4.1/node_modules/@sanity/types/lib/index.mjs","../../../../node_modules/.pnpm/@sanity+util@3.88.0_@types+react@19.1.6_debug@4.4.1/node_modules/@sanity/util/lib/paths.mjs","../../src/react/useOptimisticActor.ts","../../src/react/useDocuments.ts","../../src/util/randomKey.ts","../../src/util/mutations.ts"],"sourcesContent":["function isObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\" && typeof reference._dataset == \"string\" && typeof reference._projectId == \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id == \"string\" && typeof document._type == \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type == \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key == \"string\";\n}\nfunction isGlobalDocumentReference(reference) {\n  return !isObject(reference) || typeof reference._ref != \"string\" ? !1 : reference._ref.split(\":\").length === 3;\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nconst MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME = \"sanity.asset.aspect\";\nfunction isAssetAspect(maybeAssetAspect) {\n  return typeof maybeAssetAspect == \"object\" && maybeAssetAspect !== null && \"_type\" in maybeAssetAspect && maybeAssetAspect._type === MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME;\n}\nfunction defineAssetAspect(definition) {\n  const { assetType, name } = definition;\n  return {\n    _type: MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME,\n    _id: `${name}`,\n    definition,\n    ...assetType && {\n      assetType: Array.isArray(assetType) ? assetType : [assetType]\n    }\n  };\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type == \"string\" && // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : !0) && (\"style\" in value ? typeof value.style == \"string\" : !0);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text == \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark == \"string\") : !0);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem == \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type))\n    return !1;\n  let current = type;\n  for (; current; ) {\n    if (current.name === \"document\")\n      return !0;\n    current = current.type;\n  }\n  return !1;\n}\nfunction isObjectSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"object\" : !1;\n}\nfunction isArraySchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"array\" : !1;\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"boolean\" : !1;\n}\nfunction isStringSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"string\" : !1;\n}\nfunction isNumberSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"number\" : !1;\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isImageSchemaType(type) {\n  return isRecord(type) && (type.name === \"image\" || isImageSchemaType(type.type));\n}\nfunction isFileSchemaType(type) {\n  return isRecord(type) && (type.name === \"file\" || isFileSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isDeprecationConfiguration(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item == \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type) || !Array.isArray(type.fields)) return !1;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  return !isRecord(field) || field.name !== \"style\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  return !isRecord(field) || field.name !== \"listItem\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  return !isRecord(field) || field.name !== \"children\" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nconst searchStrategies = [\"groqLegacy\", \"groq2024\"];\nfunction isSearchStrategy(maybeSearchStrategy) {\n  return searchStrategies.includes(maybeSearchStrategy);\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current == \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport {\n  MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME,\n  defineArrayMember,\n  defineAssetAspect,\n  defineField,\n  defineType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isArrayOfPrimitivesSchemaType,\n  isArraySchemaType,\n  isAssetAspect,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isBooleanSchemaType,\n  isCreateIfNotExistsMutation,\n  isCreateMutation,\n  isCreateOrReplaceMutation,\n  isCreateSquashedMutation,\n  isCrossDatasetReference,\n  isCrossDatasetReferenceSchemaType,\n  isDeleteMutation,\n  isDeprecatedSchemaType,\n  isDeprecationConfiguration,\n  isDocumentSchemaType,\n  isFileSchemaType,\n  isGlobalDocumentReference,\n  isImage,\n  isImageSchemaType,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  isKeyedObject,\n  isNumberSchemaType,\n  isObjectSchemaType,\n  isPatchMutation,\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  isPrimitiveSchemaType,\n  isReference,\n  isReferenceSchemaType,\n  isSanityDocument,\n  isSearchStrategy,\n  isSlug,\n  isSpanSchemaType,\n  isStringSchemaType,\n  isTitledListValue,\n  isTypedObject,\n  isValidationError,\n  isValidationErrorMarker,\n  isValidationInfo,\n  isValidationInfoMarker,\n  isValidationWarning,\n  isValidationWarningMarker,\n  searchStrategies,\n  typed\n};\n//# sourceMappingURL=index.mjs.map\n","import { isIndexSegment, isKeySegment, isIndexTuple } from \"@sanity/types\";\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = \"$\", GROQ_DATA_TYPE_VALUES = [\"true\", \"false\", \"null\"];\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nconst pathsMemo = /* @__PURE__ */ new Map();\nfunction pathFor(path) {\n  if (path.length === 0)\n    return EMPTY_PATH;\n  const asString = toString(path);\n  return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);\n}\nfunction isEqual(path, otherPath) {\n  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));\n}\nfunction numEqualSegments(path, otherPath) {\n  const length = Math.min(path.length, otherPath.length);\n  for (let i = 0; i < length; i++)\n    if (!isSegmentEqual(path[i], otherPath[i]))\n      return i;\n  return length;\n}\nfunction isSegmentEqual(segmentA, segmentB) {\n  return isKeySegment(segmentA) && isKeySegment(segmentB) ? segmentA._key === segmentB._key : isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : isIndexTuple(segmentA) && isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;\n}\nfunction hasFocus(focusPath, path) {\n  const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;\n  return isEqual(withoutTerminator, path);\n}\nfunction hasItemFocus(focusPath, item) {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);\n}\nfunction isExpanded(segment, focusPath) {\n  const [head, ...tail] = focusPath;\n  return tail.length > 0 && isSegmentEqual(segment, head);\n}\nfunction startsWith(prefix, path) {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));\n}\nfunction trimLeft(prefix, path) {\n  if (prefix.length === 0 || path.length === 0)\n    return path;\n  const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;\n  return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;\n}\nfunction trimRight(suffix, path) {\n  const sufLen = suffix.length, pathLen = path.length;\n  if (sufLen === 0 || pathLen === 0)\n    return path;\n  let i = 0;\n  for (; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]); )\n    i++;\n  return pathFor(path.slice(0, pathLen - i));\n}\nfunction trimChildPath(path, childPath) {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const isHead = i === 0;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\")\n      return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}[\"${segment}\"]` : `${target}.${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction _resolveKeyedPath(value, path) {\n  if (path.length === 0)\n    return path;\n  const [next, ...rest] = path;\n  if (typeof next == \"number\") {\n    if (!Array.isArray(value) || !(next in value))\n      return [];\n    const item = value[next];\n    return [typeof item?._key == \"string\" ? { _key: item._key } : next, ..._resolveKeyedPath(item, rest)];\n  }\n  const nextVal = get(value, [next]);\n  return [next, ..._resolveKeyedPath(nextVal, rest)];\n}\nfunction resolveKeyedPath(value, path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return pathFor(_resolveKeyedPath(value, path));\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(normalizePathSegment);\n}\nfunction normalizePathSegment(segment) {\n  return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;\n}\nfunction normalizeIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction normalizeKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction normalizeIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nexport {\n  FOCUS_TERMINATOR,\n  _resolveKeyedPath,\n  fromString,\n  get,\n  hasFocus,\n  hasItemFocus,\n  isEqual,\n  isExpanded,\n  isSegmentEqual,\n  numEqualSegments,\n  pathFor,\n  resolveKeyedPath,\n  startsWith,\n  toString,\n  trimChildPath,\n  trimLeft,\n  trimRight\n};\n//# sourceMappingURL=paths.mjs.map\n","import {useCallback, useMemo, useSyncExternalStore} from 'react'\nimport {\n  actor,\n  emptyActor,\n  isEmptyActor,\n  listeners,\n  type EmptyActor,\n  type MutatorActor,\n} from '../optimistic/context'\n\nexport function useOptimisticActor(): MutatorActor | EmptyActor {\n  const subscribe = useCallback((listener: () => void) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }, [])\n\n  const actorRef = useSyncExternalStore(\n    subscribe,\n    () => actor,\n    () => emptyActor,\n  )\n\n  return actorRef\n}\n\nexport function useOptimisticActorReady(): boolean {\n  const actor = useOptimisticActor()\n  return useMemo(() => !isEmptyActor(actor), [actor])\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {SanityDocument} from '@sanity/client'\nimport {getDraftId, getPublishedId} from '@sanity/client/csm'\nimport {createIfNotExists, patch} from '@sanity/mutate'\nimport {isMaybePreviewIframe, isMaybePreviewWindow} from '@sanity/presentation-comlink'\nimport {get as getAtPath} from '@sanity/util/paths'\nimport {useCallback} from 'react'\nimport {isEmptyActor, type MutatorActor} from '../optimistic/context'\nimport type {\n  DocumentsGet,\n  DocumentsMutate,\n  OptimisticDocumentPatches,\n  Path,\n  PathValue,\n} from '../optimistic/types'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nfunction debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(fn: F, timeout: number): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n\nfunction getDocumentsAndSnapshot<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  const inFrame = isMaybePreviewIframe()\n  const inPopUp = isMaybePreviewWindow()\n\n  if (isEmptyActor(actor) || (!inFrame && !inPopUp)) {\n    throw new Error('The `useDocuments` hook cannot be used in this context')\n  }\n\n  const draftId = getDraftId(id)\n  const publishedId = getPublishedId(id)\n  const documents = actor.getSnapshot().context?.documents\n\n  const draftDoc = documents?.[draftId]\n  const publishedDoc = documents?.[publishedId]\n  const doc = draftDoc || publishedDoc\n\n  if (!doc) {\n    throw new Error(`Document \"${id}\" not found`)\n  }\n\n  // Helper to get the snapshot from the draft document if it exists, otherwise\n  // fall back to the published document\n  const getDocumentSnapshot = () =>\n    (draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local) as\n      | SanityDocument<T>\n      | null\n      | undefined\n\n  const snapshot = getDocumentSnapshot()\n  const snapshotPromise = new Promise<SanityDocument<T> | null>((resolve) => {\n    if (snapshot) {\n      resolve(snapshot)\n    } else {\n      const subscriber = doc.on('ready', (event) => {\n        // Assert type here as the original document mutator machine doesn't\n        // emit a 'ready' event. We provide a custom action to emit it in this\n        // package's internal `createDatasetMutator` function. <3 xstate.\n        const {snapshot} = event as unknown as {snapshot: SanityDocument<T> | null | undefined}\n        resolve(snapshot || null)\n        subscriber.unsubscribe()\n      })\n    }\n  })\n\n  const getSnapshot = () => snapshotPromise\n\n  return {\n    draftDoc,\n    draftId,\n    getSnapshot,\n    publishedDoc,\n    publishedId,\n    /**\n     * @deprecated - use `getSnapshot` instead\n     */\n    get snapshot() {\n      // Maintain original error throwing behaviour, to avoid breaking changes\n      if (!snapshot) {\n        throw new Error(`Snapshot for document \"${id}\" not found`)\n      }\n      return snapshot\n    },\n  }\n}\n\nfunction createDocumentCommit<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (): void => {\n    const {draftDoc} = getDocumentsAndSnapshot<T>(id, actor)\n    draftDoc.send({type: 'submit'})\n  }\n}\n\n/**\n * @deprecated - superseded by `createDocumentGetSnapshot`\n */\nfunction createDocumentGet<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return <P extends Path<T, keyof T>>(\n    path?: P,\n  ): PathValue<T, P> | SanityDocument<T> | undefined => {\n    const {snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    return path\n      ? (getAtPath(snapshot, path) as PathValue<T, P>)\n      : (snapshot as unknown as SanityDocument<T>)\n  }\n}\n\nfunction createDocumentGetSnapshot<T extends Record<string, any>>(\n  id: string,\n  actor: MutatorActor,\n): () => Promise<SanityDocument<T> | null> {\n  const {getSnapshot} = getDocumentsAndSnapshot<T>(id, actor)\n  return getSnapshot\n}\n\nfunction createDocumentPatch<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return async (\n    patches: OptimisticDocumentPatches<T>,\n    options?: {commit?: boolean | {debounce: number}},\n  ): Promise<void> => {\n    // Destructure the function result in two steps as we need access to the\n    // `result.snapshot` property in the getter, but don't want to execute the\n    // getter prematurely as it may throw\n    const result = getDocumentsAndSnapshot<T>(id, actor)\n    const {draftDoc, draftId, getSnapshot, publishedId} = result\n\n    const {commit = true} = options || {}\n\n    const context = {\n      draftId,\n      publishedId,\n      /**\n       * @deprecated - use `getSnapshot` instead\n       */\n      get snapshot() {\n        return result.snapshot\n      },\n      getSnapshot,\n    }\n\n    const resolvedPatches = await (typeof patches === 'function' ? patches(context) : patches)\n\n    const _snapshot = await getSnapshot()\n\n    if (!_snapshot) {\n      throw new Error(`Snapshot for document \"${id}\" not found`)\n    }\n\n    draftDoc.send({\n      type: 'mutate',\n      mutations: [\n        // Attempt to create the draft document, it might not exist if the\n        // snapshot was from the published document\n        createIfNotExists({..._snapshot, _id: draftId}),\n        // Patch the draft document with the resolved patches\n        patch(draftId, resolvedPatches),\n      ],\n    })\n\n    if (commit) {\n      if (typeof commit === 'object' && 'debounce' in commit) {\n        const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n        debouncedCommit()\n      } else {\n        draftDoc.send({type: 'submit'})\n      }\n    }\n  }\n}\n\nexport function useDocuments(): {\n  getDocument: DocumentsGet\n  mutateDocument: DocumentsMutate\n} {\n  const actor = useOptimisticActor() as MutatorActor\n\n  const getDocument: DocumentsGet = useCallback(\n    <T extends Record<string, any>>(documentId: string) => {\n      return {\n        id: documentId,\n        commit: createDocumentCommit(documentId, actor),\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - Type instantiation is excessively deep and possibly infinite.\n        get: createDocumentGet(documentId, actor),\n        getSnapshot: createDocumentGetSnapshot<T>(documentId, actor),\n        patch: createDocumentPatch<T>(documentId, actor),\n      }\n    },\n    [actor],\n  )\n\n  const mutateDocument: DocumentsMutate = useCallback(\n    (id, mutations, options) => {\n      const {draftDoc} = getDocumentsAndSnapshot(id, actor)\n      const {commit = true} = options || {}\n\n      draftDoc.send({\n        type: 'mutate',\n        mutations: mutations,\n      })\n\n      if (commit) {\n        if (typeof commit === 'object' && 'debounce' in commit) {\n          const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n          debouncedCommit()\n        } else {\n          draftDoc.send({type: 'submit'})\n        }\n      }\n    },\n    [actor],\n  )\n\n  return {getDocument, mutateDocument}\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst getByteHexTable = (() => {\n  let table: string[]\n  return () => {\n    if (table) {\n      return table\n    }\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\nexport function randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SanityDocument} from '@sanity/client'\nimport {at, insert, truncate, type NodePatchList} from '@sanity/mutate'\nimport type {SanityNode} from '@sanity/presentation-comlink'\nimport {get} from '@sanity/util/paths'\nimport type {OptimisticDocument} from '../optimistic/types'\nimport {randomKey} from './randomKey'\n\nexport function getArrayItemKeyAndParentPath(pathOrNode: string | SanityNode): {\n  path: string\n  key: string\n  hasExplicitKey: boolean\n} {\n  const elementPath = typeof pathOrNode === 'string' ? pathOrNode : pathOrNode.path\n\n  const lastDotIndex = elementPath.lastIndexOf('.')\n  const lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length)\n\n  if (!lastPathItem.indexOf('[')) throw new Error('Invalid path: not an array')\n\n  const lastArrayIndex = elementPath.lastIndexOf('[')\n  const path = elementPath.substring(0, lastArrayIndex)\n\n  let key\n  let hasExplicitKey\n\n  if (lastPathItem.includes('_key')) {\n    // explicit [_key=\"...\"]\n\n    const startIndex = lastPathItem.indexOf('\"') + 1\n    const endIndex = lastPathItem.indexOf('\"', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = true\n  } else {\n    // indexes [int]\n    const startIndex = lastPathItem.indexOf('[') + 1\n    const endIndex = lastPathItem.indexOf(']', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = false\n  }\n\n  if (!path || !key) throw new Error('Invalid path')\n\n  return {\n    path,\n    key,\n    hasExplicitKey,\n  }\n}\n\nexport function getArrayDuplicatePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n  position: 'before' | 'after' = 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const item = get(snapshot, node.path) as object\n  const duplicate = {...item, _key: randomKey()}\n\n  return [at(arrayPath, insert(duplicate, position, {_key: itemKey}))]\n}\n\nexport function getArrayRemovePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n  return [at(arrayPath, truncate(currentIndex, currentIndex + 1))]\n}\n\nexport function getArrayInsertPatches(\n  node: SanityNode,\n  insertType: string,\n  position: 'before' | 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const insertKey = randomKey()\n  const referenceItem = {_key: itemKey}\n  return [at(arrayPath, insert([{_type: insertType, _key: insertKey}], position, referenceItem))]\n}\n\nexport async function getArrayMovePatches(\n  node: SanityNode,\n  doc: OptimisticDocument,\n  moveTo: 'previous' | 'next' | 'first' | 'last',\n): Promise<NodePatchList> {\n  if (!node.type) throw new Error('Node type is missing')\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const snapshot = await doc.getSnapshot()\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const item = get(snapshot, node.path)\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n\n  let nextIndex = -1\n  let position: 'before' | 'after' = 'before'\n\n  if (moveTo === 'first') {\n    if (currentIndex === 0) return []\n    nextIndex = 0\n    position = 'before'\n  } else if (moveTo === 'last') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = -1\n    position = 'after'\n  } else if (moveTo === 'next') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = currentIndex\n    position = 'after'\n  } else if (moveTo === 'previous') {\n    if (currentIndex === 0) return []\n    nextIndex = currentIndex - 1\n    position = 'before'\n  }\n\n  return [\n    at(arrayPath, truncate(currentIndex, currentIndex + 1)),\n    at(arrayPath, insert(item, position, nextIndex)),\n  ]\n}\n"],"names":["reKeySegment","useOptimisticActor","useSyncExternalStore","_temp","_temp2","_temp3","emptyActor","actor","listener","listeners","add","delete","useOptimisticActorReady","t0","isEmptyActor","debounce","fn","timeout","timer","args","clearTimeout","setTimeout","apply","getDocumentsAndSnapshot","id","inFrame","isMaybePreviewIframe","inPopUp","isMaybePreviewWindow","Error","draftId","getDraftId","publishedId","getPublishedId","documents","getSnapshot","context","draftDoc","publishedDoc","doc","snapshot","local","snapshotPromise","Promise","resolve","subscriber","on","event","unsubscribe","createDocumentCommit","send","type","createDocumentGet","path","getAtPath","createDocumentGetSnapshot","createDocumentPatch","patches","options","result","commit","resolvedPatches","_snapshot","mutations","createIfNotExists","_id","patch","useDocuments","$","_c","documentId","get","getDocument","t1","t2","undefined","mutateDocument","whatwgRNG","length","rnds8","Uint8Array","getRandomValues","getByteHexTable","table","i","toString","slice","randomKey","reduce","str","n","getArrayItemKeyAndParentPath","pathOrNode","elementPath","lastDotIndex","lastIndexOf","lastPathItem","substring","indexOf","lastArrayIndex","key","hasExplicitKey","includes","startIndex","endIndex","getArrayDuplicatePatches","node","position","arrayPath","itemKey","duplicate","_key","at","insert","getArrayRemovePatches","currentIndex","findIndex","item","truncate","getArrayInsertPatches","insertType","insertKey","_type","getArrayMovePatches","moveTo","array","nextIndex"],"mappings":"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","x_google_ignoreList":[0,1]}