import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { createCompatibilityActors, isMaybePreviewIframe, isMaybePreviewWindow } from "@sanity/presentation-comlink";
import { useEffect, createContext, useContext, useState, memo, useRef, useId, Fragment as Fragment$1, isValidElement, useSyncExternalStore, useDeferredValue, useReducer } from "react";
import { createPortal } from "react-dom";
import { createEditUrl, studioPath, getDraftId, getPublishedId } from "@sanity/client/csm";
import { MenuGroup, MenuDivider, MenuItem, Box, Text, Spinner, Stack, Flex, Menu, Popover, Button, Card, usePrefersDark, useTheme_v2, Hotkeys, LayerProvider, PortalProvider, ThemeProvider, studioTheme, isHTMLAnchorElement, isHTMLElement } from "@sanity/ui/_visual-editing";
import { styled } from "styled-components";
import { useDocuments, getArrayItemKeyAndParentPath, get, getArrayMovePatches, getArrayInsertPatches, getArrayDuplicatePatches, getArrayRemovePatches, useOptimisticActorReady, useOptimisticActor } from "../_chunks-es/mutations.js";
import { v4, SharedStateContext, createOverlayController, sanityNodesExistInSameArray } from "../_chunks-es/SharedStateContext.js";
import { useOptimistic } from "../_chunks-es/SharedStateContext.js";
import { at, remove, insert } from "@sanity/mutate";
import { getNodeIcon, InsertMenu, PopoverPortal, useTelemetry, PopoverBackground, PointerEvents, TelemetryContext, events } from "../_chunks-es/PointerEvents.js";
import { InsertAboveIcon, InsertBelowIcon, CopyIcon, RemoveIcon, SortIcon, PublishIcon, ArrowUpIcon, ArrowDownIcon, UnpublishIcon, DragHandleIcon, PlugIcon, EllipsisVerticalIcon, DocumentIcon, ExpandIcon } from "@sanity/icons";
import { MenuButton, MenuDivider as MenuDivider$1 } from "@sanity/ui";
import { pathToUrlString } from "@sanity/visual-editing-csm";
import { createDataAttribute } from "@sanity/visual-editing-csm";
import scrollIntoView from "scroll-into-view-if-needed";
import { createNode, createNodeMachine } from "@sanity/comlink";
import { createActor } from "xstate";
import { setActor } from "../_chunks-es/context.js";
import { emptyActor } from "../_chunks-es/context.js";
import { ReplaySubject, Subject, merge } from "rxjs";
import { createDatasetMutator } from "../optimistic/index.js";
import { createDocumentMutator } from "../optimistic/index.js";
const History = (props) => {
  const $ = c(8), {
    comlink,
    history
  } = props;
  let t0, t1;
  $[0] !== comlink || $[1] !== history ? (t0 = () => comlink?.on("presentation/navigate", (data) => {
    history?.update(data);
  }), t1 = [comlink, history], $[0] = comlink, $[1] = history, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), useEffect(t0, t1);
  let t2, t3;
  return $[4] !== comlink || $[5] !== history ? (t2 = () => {
    if (history)
      return history.subscribe((update) => {
        update.title = update.title || document.title, comlink?.post("visual-editing/navigate", update);
      });
  }, t3 = [comlink, history], $[4] = comlink, $[5] = history, $[6] = t2, $[7] = t3) : (t2 = $[6], t3 = $[7]), useEffect(t2, t3), null;
}, Meta = (props) => {
  const $ = c(3), {
    comlink
  } = props;
  let t0, t1;
  return $[0] !== comlink ? (t0 = () => {
    const sendMeta = () => {
      comlink.post("visual-editing/meta", {
        title: document.title
      });
    }, observer = new MutationObserver((t2) => {
      const [mutation] = t2;
      mutation.target.nodeName === "TITLE" && sendMeta();
    });
    return observer.observe(document.head, {
      subtree: !0,
      characterData: !0,
      childList: !0
    }), sendMeta(), () => observer.disconnect();
  }, t1 = [comlink], $[0] = comlink, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1), null;
};
function getReferenceNodeAndInsertPosition(position) {
  if (position) {
    const {
      top,
      right,
      bottom,
      left
    } = position;
    if (left || top)
      return {
        node: (left ?? top).sanity,
        position: "after"
      };
    if (right || bottom)
      return {
        node: (right ?? bottom).sanity,
        position: "before"
      };
  }
}
function useDragEndEvents() {
  const $ = c(4), {
    getDocument
  } = useDocuments();
  let t0, t1;
  $[0] !== getDocument ? (t0 = () => {
    const handler = (e) => {
      const {
        insertPosition,
        target,
        preventInsertDefault
      } = e.detail;
      if (preventInsertDefault)
        return;
      const reference = getReferenceNodeAndInsertPosition(insertPosition);
      if (reference) {
        const doc = getDocument(target.id), {
          node,
          position
        } = reference, {
          key: targetKey,
          hasExplicitKey
        } = getArrayItemKeyAndParentPath(target), {
          path: arrayPath,
          key: referenceItemKey
        } = getArrayItemKeyAndParentPath(node);
        arrayPath && referenceItemKey && referenceItemKey !== targetKey && doc.patch(async (t22) => {
          const {
            getSnapshot
          } = t22, snapshot = await getSnapshot(), elementValue = get(snapshot, target.path);
          return hasExplicitKey ? [at(arrayPath, remove({
            _key: targetKey
          })), at(arrayPath, insert(elementValue, position, {
            _key: referenceItemKey
          }))] : [at(arrayPath, remove(~~targetKey)), at(arrayPath, insert(elementValue, position, referenceItemKey > targetKey ? ~~referenceItemKey - 1 : ~~referenceItemKey))];
        });
      }
    };
    return window.addEventListener("sanity/dragEnd", handler), () => {
      window.removeEventListener("sanity/dragEnd", handler);
    };
  }, t1 = [getDocument], $[0] = getDocument, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
  const dispatchDragEndEvent = _temp$9;
  let t2;
  return $[3] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    dispatchDragEndEvent
  }, $[3] = t2) : t2 = $[3], t2;
}
function _temp$9(event) {
  const customEvent = new CustomEvent("sanity/dragEnd", {
    detail: event,
    cancelable: !0
  });
  window.dispatchEvent(customEvent);
}
const SchemaContext = createContext(null);
function useSchema() {
  const context = useContext(SchemaContext);
  if (!context)
    throw new Error("Schema context is missing");
  return context;
}
function getArrayRemoveAction(node, doc) {
  if (!node.type) throw new Error("Node type is missing");
  return () => doc.patch(async ({
    getSnapshot
  }) => getArrayRemovePatches(node, await getSnapshot()));
}
function getArrayInsertAction(node, doc, insertType, position) {
  if (!node.type) throw new Error("Node type is missing");
  return () => doc.patch(() => getArrayInsertPatches(node, insertType, position));
}
function getDuplicateAction(node, doc) {
  if (!node.type) throw new Error("Node type is missing");
  return () => doc.patch(async ({
    getSnapshot
  }) => getArrayDuplicatePatches(node, await getSnapshot()));
}
function getContextMenuItems(context) {
  const {
    node,
    field,
    parent,
    doc
  } = context;
  return field?.type === "arrayItem" ? getContextMenuArrayItems({
    node,
    field,
    doc
  }) : parent?.type === "union" ? getContextMenuUnionItems({
    node,
    parent,
    doc
  }) : Promise.resolve([]);
}
function getDuplicateItem(context) {
  const {
    node,
    doc
  } = context;
  return doc ? [{
    type: "action",
    label: "Duplicate",
    icon: CopyIcon,
    action: getDuplicateAction(node, doc),
    telemetryEvent: "Visual Editing Context Menu Item Duplicated"
  }] : [];
}
function getRemoveItems(context) {
  const {
    node,
    doc
  } = context;
  return doc ? [{
    type: "action",
    label: "Remove",
    icon: RemoveIcon,
    action: getArrayRemoveAction(node, doc),
    telemetryEvent: "Visual Editing Context Menu Item Removed"
  }] : [];
}
async function getMoveItems(context, withDivider = !0) {
  const {
    node,
    doc
  } = context;
  if (!doc) return [];
  const items = [], groupItems = [], [moveUpPatches, moveDownPatches, moveFirstPatches, moveLastPatches] = await Promise.all([getArrayMovePatches(node, doc, "previous"), getArrayMovePatches(node, doc, "next"), getArrayMovePatches(node, doc, "first"), getArrayMovePatches(node, doc, "last")]);
  return moveFirstPatches.length && groupItems.push({
    type: "action",
    label: "To top",
    icon: PublishIcon,
    action: () => doc.patch(moveFirstPatches),
    telemetryEvent: "Visual Editing Context Menu Item Moved"
  }), moveUpPatches.length && groupItems.push({
    type: "action",
    label: "Up",
    icon: ArrowUpIcon,
    action: () => doc.patch(moveUpPatches),
    telemetryEvent: "Visual Editing Context Menu Item Moved"
  }), moveDownPatches.length && groupItems.push({
    type: "action",
    label: "Down",
    icon: ArrowDownIcon,
    action: () => doc.patch(moveDownPatches),
    telemetryEvent: "Visual Editing Context Menu Item Moved"
  }), moveLastPatches.length && groupItems.push({
    type: "action",
    label: "To bottom",
    icon: UnpublishIcon,
    action: () => doc.patch(moveLastPatches),
    telemetryEvent: "Visual Editing Context Menu Item Moved"
  }), groupItems.length && (items.push({
    type: "group",
    label: "Move",
    icon: SortIcon,
    items: groupItems
  }), withDivider && items.push({
    type: "divider"
  })), items;
}
async function getContextMenuArrayItems(context) {
  const {
    node,
    field,
    doc
  } = context, items = [];
  return items.push(...getDuplicateItem(context)), items.push(...getRemoveItems(context)), items.push(...await getMoveItems(context)), items.push({
    type: "action",
    label: "Insert before",
    icon: InsertAboveIcon,
    action: getArrayInsertAction(node, doc, field.name, "before"),
    telemetryEvent: "Visual Editing Context Menu Item Inserted"
  }), items.push({
    type: "action",
    label: "Insert after",
    icon: InsertBelowIcon,
    action: getArrayInsertAction(node, doc, field.name, "after"),
    telemetryEvent: "Visual Editing Context Menu Item Inserted"
  }), items;
}
const InsertMenuWrapper = (props) => {
  const $ = c(12), {
    label,
    parent,
    width,
    onSelect,
    boundaryElement
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = ["left-start", "right", "left", "right-end", "left-end", "bottom", "top"], $[0] = t0) : t0 = $[0];
  let t1;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [4, 4, 4, 4], $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== boundaryElement || $[3] !== width ? (t2 = {
    arrow: !1,
    constrainSize: !0,
    floatingBoundary: boundaryElement,
    padding: 0,
    placement: "right-start",
    fallbackPlacements: t0,
    preventOverflow: !0,
    width,
    __unstable_margins: t1
  }, $[2] = boundaryElement, $[3] = width, $[4] = t2) : t2 = $[4];
  let t3;
  $[5] !== onSelect || $[6] !== parent ? (t3 = /* @__PURE__ */ jsx(InsertMenu, { node: parent, onSelect }), $[5] = onSelect, $[6] = parent, $[7] = t3) : t3 = $[7];
  let t4;
  return $[8] !== label || $[9] !== t2 || $[10] !== t3 ? (t4 = /* @__PURE__ */ jsx(MenuGroup, { fontSize: 1, icon: InsertBelowIcon, padding: 2, popover: t2, space: 2, text: label, children: t3 }), $[8] = label, $[9] = t2, $[10] = t3, $[11] = t4) : t4 = $[11], t4;
};
async function getContextMenuUnionItems(context) {
  const {
    doc,
    node,
    parent
  } = context, items = [];
  if (items.push(...getDuplicateItem(context)), items.push(...getRemoveItems(context)), items.push(...await getMoveItems(context)), parent.options?.insertMenu) {
    const width = (parent.options.insertMenu || {}).views?.some((view) => view.name === "grid") ? 0 : void 0;
    items.push({
      type: "custom",
      component: ({
        boundaryElement,
        sendTelemetry
      }) => /* @__PURE__ */ jsx(InsertMenuWrapper, { label: "Insert before", onSelect: (schemaType) => {
        getArrayInsertAction(node, doc, schemaType.name, "before")(), sendTelemetry("Visual Editing Context Menu Item Inserted", null);
      }, parent, width, boundaryElement })
    }), items.push({
      type: "custom",
      component: ({
        boundaryElement,
        sendTelemetry
      }) => /* @__PURE__ */ jsx(InsertMenuWrapper, { label: "Insert after", onSelect: (schemaType) => {
        getArrayInsertAction(node, doc, schemaType.name, "after")(), sendTelemetry("Visual Editing Context Menu Item Inserted", null);
      }, parent, width, boundaryElement })
    });
  } else
    items.push({
      type: "group",
      label: "Insert before",
      icon: InsertAboveIcon,
      items: parent.of.filter((item) => item.type === "unionOption").map((t) => ({
        type: "action",
        icon: getNodeIcon(t),
        label: t.name === "block" ? "Paragraph" : t.title || t.name,
        action: getArrayInsertAction(node, doc, t.name, "before"),
        telemetryEvent: "Visual Editing Context Menu Item Inserted"
      }))
    }), items.push({
      type: "group",
      label: "Insert after",
      icon: InsertBelowIcon,
      items: parent.of.filter((item) => item.type === "unionOption").map((t) => ({
        type: "action",
        label: t.name === "block" ? "Paragraph" : t.title || t.name,
        icon: getNodeIcon(t),
        action: getArrayInsertAction(node, doc, t.name, "after"),
        telemetryEvent: "Visual Editing Context Menu Item Inserted"
      }))
    });
  return items;
}
const POPOVER_MARGINS = [-4, 4, -4, 4];
function ContextMenuItem(props) {
  const $ = c(27), {
    node,
    onDismiss,
    boundaryElement
  } = props, sendTelemetry = useTelemetry();
  let t0;
  $[0] !== node || $[1] !== onDismiss || $[2] !== sendTelemetry ? (t0 = () => {
    node.type === "action" && (node.action?.(), onDismiss?.(), node.telemetryEvent && sendTelemetry(node.telemetryEvent, null));
  }, $[0] = node, $[1] = onDismiss, $[2] = sendTelemetry, $[3] = t0) : t0 = $[3];
  const onClick = t0;
  if (node.type === "divider") {
    let t1;
    return $[4] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsx(MenuDivider, {}), $[4] = t1) : t1 = $[4], t1;
  }
  if (node.type === "action") {
    const t1 = !node.action;
    let t2;
    return $[5] !== node.hotkeys || $[6] !== node.icon || $[7] !== node.label || $[8] !== onClick || $[9] !== t1 ? (t2 = /* @__PURE__ */ jsx(MenuItem, { fontSize: 1, hotkeys: node.hotkeys, icon: node.icon, padding: 2, space: 2, text: node.label, disabled: t1, onClick }), $[5] = node.hotkeys, $[6] = node.icon, $[7] = node.label, $[8] = onClick, $[9] = t1, $[10] = t2) : t2 = $[10], t2;
  }
  if (node.type === "group") {
    const t1 = node.icon;
    let t2;
    $[11] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {
      arrow: !1,
      constrainSize: !0,
      placement: "right-start",
      fallbackPlacements: ["left-start", "right", "left", "right-end", "left-end", "bottom", "top"],
      preventOverflow: !0,
      __unstable_margins: POPOVER_MARGINS
    }, $[11] = t2) : t2 = $[11];
    const t3 = node.label;
    let t4;
    if ($[12] !== boundaryElement || $[13] !== node.items || $[14] !== onDismiss) {
      let t52;
      $[16] !== boundaryElement || $[17] !== onDismiss ? (t52 = (item, itemIndex) => /* @__PURE__ */ jsx(ContextMenuItem, { node: item, onDismiss, boundaryElement }, itemIndex), $[16] = boundaryElement, $[17] = onDismiss, $[18] = t52) : t52 = $[18], t4 = node.items.map(t52), $[12] = boundaryElement, $[13] = node.items, $[14] = onDismiss, $[15] = t4;
    } else
      t4 = $[15];
    let t5;
    return $[19] !== node.icon || $[20] !== node.label || $[21] !== t4 ? (t5 = /* @__PURE__ */ jsx(MenuGroup, { fontSize: 1, icon: t1, padding: 2, popover: t2, space: 2, text: t3, children: t4 }), $[19] = node.icon, $[20] = node.label, $[21] = t4, $[22] = t5) : t5 = $[22], t5;
  }
  if (node.type === "custom") {
    const {
      component: Component
    } = node;
    let t1;
    return $[23] !== Component || $[24] !== boundaryElement || $[25] !== sendTelemetry ? (t1 = /* @__PURE__ */ jsx(Component, { boundaryElement, sendTelemetry }), $[23] = Component, $[24] = boundaryElement, $[25] = sendTelemetry, $[26] = t1) : t1 = $[26], t1;
  }
  return null;
}
const ContextMenu = (props) => {
  const $ = c(43), {
    node,
    onDismiss,
    position: t0
  } = props, {
    x,
    y
  } = t0, [boundaryElement, setBoundaryElement] = useState(null), {
    getField
  } = useSchema(), {
    getDocument
  } = useDocuments();
  let t1;
  $[0] !== getField || $[1] !== node ? (t1 = getField(node), $[0] = getField, $[1] = node, $[2] = t1) : t1 = $[2];
  const {
    field,
    parent
  } = t1;
  let t2;
  t2 = field?.title || field?.name || "Unknown type";
  const title = t2, [items, setItems] = useState(void 0);
  let t3, t4;
  $[3] !== field || $[4] !== getDocument || $[5] !== node || $[6] !== parent ? (t3 = () => {
    (async () => {
      const doc = getDocument(node.id);
      if (!doc)
        return;
      const items_0 = await getContextMenuItems({
        node,
        field,
        parent,
        doc
      });
      setItems(items_0);
    })();
  }, t4 = [field, node, parent, getDocument], $[3] = field, $[4] = getDocument, $[5] = node, $[6] = parent, $[7] = t3, $[8] = t4) : (t3 = $[7], t4 = $[8]), useEffect(t3, t4);
  let t5, t6;
  $[9] !== x || $[10] !== y ? (t6 = {
    getBoundingClientRect: () => ({
      bottom: y,
      left: x,
      right: x,
      top: y,
      width: 0,
      height: 0
    })
  }, $[9] = x, $[10] = y, $[11] = t6) : t6 = $[11], t5 = t6;
  const contextMenuReferenceElement = t5;
  let t7, t8;
  $[12] !== field ? (t8 = getNodeIcon(field), $[12] = field, $[13] = t8) : t8 = $[13], t7 = t8;
  const icon = t7;
  let t9;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t9 = {
    minWidth: 120,
    maxWidth: 160
  }, $[14] = t9) : t9 = $[14];
  let t10;
  $[15] !== icon || $[16] !== items ? (t10 = /* @__PURE__ */ jsx(Box, { flex: "none", children: items ? /* @__PURE__ */ jsx(Text, { size: 1, children: icon }) : /* @__PURE__ */ jsx(Spinner, { size: 1 }) }), $[15] = icon, $[16] = items, $[17] = t10) : t10 = $[17];
  const t11 = items ? title : "Loading...";
  let t12;
  $[18] !== t11 ? (t12 = /* @__PURE__ */ jsx(Stack, { flex: 1, space: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: t11 }) }), $[18] = t11, $[19] = t12) : t12 = $[19];
  let t13;
  $[20] !== t10 || $[21] !== t12 ? (t13 = /* @__PURE__ */ jsxs(Flex, { gap: 2, padding: 2, children: [
    t10,
    t12
  ] }), $[20] = t10, $[21] = t12, $[22] = t13) : t13 = $[22];
  let t14;
  $[23] !== boundaryElement || $[24] !== items || $[25] !== onDismiss ? (t14 = items && /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(MenuDivider, {}),
    items.map((item, i) => /* @__PURE__ */ jsx(ContextMenuItem, { node: item, onDismiss, boundaryElement }, i))
  ] }), $[23] = boundaryElement, $[24] = items, $[25] = onDismiss, $[26] = t14) : t14 = $[26];
  let t15;
  $[27] !== t13 || $[28] !== t14 ? (t15 = /* @__PURE__ */ jsxs(Menu, { style: t9, children: [
    t13,
    t14
  ] }), $[27] = t13, $[28] = t14, $[29] = t15) : t15 = $[29];
  const t16 = `${x}-${y}`;
  let t17;
  $[30] !== x || $[31] !== y ? (t17 = {
    position: "absolute",
    left: x,
    top: y
  }, $[30] = x, $[31] = y, $[32] = t17) : t17 = $[32];
  let t18;
  $[33] !== t16 || $[34] !== t17 ? (t18 = /* @__PURE__ */ jsx("div", { style: t17 }, t16), $[33] = t16, $[34] = t17, $[35] = t18) : t18 = $[35];
  let t19;
  $[36] !== contextMenuReferenceElement || $[37] !== t15 || $[38] !== t18 ? (t19 = /* @__PURE__ */ jsx(Popover, { __unstable_margins: POPOVER_MARGINS, arrow: !1, open: !0, placement: "right-start", referenceElement: contextMenuReferenceElement, content: t15, children: t18 }), $[36] = contextMenuReferenceElement, $[37] = t15, $[38] = t18, $[39] = t19) : t19 = $[39];
  let t20;
  return $[40] !== onDismiss || $[41] !== t19 ? (t20 = /* @__PURE__ */ jsx(PopoverPortal, { setBoundaryElement, onDismiss, children: t19 }), $[40] = onDismiss, $[41] = t19, $[42] = t20) : t20 = $[42], t20;
};
function getLinkHref(href, referer) {
  try {
    const parsed = new URL(href, typeof location > "u" ? void 0 : location.origin);
    if (parsed.hash) {
      const hash = new URL(getLinkHref(parsed.hash.slice(1), referer));
      return `${parsed.origin}${parsed.pathname}${parsed.search}#${hash.pathname}${hash.search}`;
    }
    return parsed.searchParams.set("preview", referer), parsed.toString();
  } catch {
    return href;
  }
}
const PreviewSnapshotsContext = createContext(null);
function usePreviewSnapshots() {
  const context = useContext(PreviewSnapshotsContext);
  if (!context)
    throw new Error("Preview Snapshots context is missing");
  return context;
}
const isReactElementOverlayComponent = (component) => isValidElement(component), Root$3 = styled(Card)`
  background-color: var(--overlay-bg);
  border-radius: 3px;
  pointer-events: none;
  position: absolute;
  will-change: transform;
  box-shadow: var(--overlay-box-shadow);
  transition: none;

  --overlay-bg: transparent;
  --overlay-box-shadow: inset 0 0 0 1px transparent;

  [data-overlays] & {
    --overlay-bg: color-mix(in srgb, transparent 95%, var(--card-focus-ring-color));
    --overlay-box-shadow: inset 0 0 0 2px
      color-mix(in srgb, transparent 50%, var(--card-focus-ring-color));
  }

  [data-fading-out] & {
    transition:
      box-shadow 1550ms,
      background-color 1550ms;

    --overlay-bg: rgba(0, 0, 255, 0);
    --overlay-box-shadow: inset 0 0 0 1px transparent;
  }

  &[data-focused] {
    --overlay-box-shadow: inset 0 0 0 1px var(--card-focus-ring-color);
  }

  &[data-hovered]:not([data-focused]) {
    transition: none;
    --overlay-box-shadow: inset 0 0 0 2px var(--card-focus-ring-color);
  }

  /* [data-unmounted] & {
    --overlay-box-shadow: inset 0 0 0 1px var(--card-focus-ring-color);
  } */

  :link {
    text-decoration: none;
  }
`, Actions = styled(Flex)`
  bottom: 100%;
  cursor: pointer;
  pointer-events: none;
  position: absolute;
  right: 0;

  [data-hovered]:not([data-menu-open]) & {
    pointer-events: all;
  }

  [data-flipped] & {
    bottom: auto;
    top: 100%;
  }
`, HUD = styled(Flex)`
  top: 100%;
  cursor: pointer;
  pointer-events: none;
  position: absolute;
  left: 0;

  gap: 4px;
  padding: 4px 0;
  flex-wrap: wrap;

  [data-hovered]:not([data-menu-open]) & {
    pointer-events: all;
  }

  [data-flipped] & {
    top: calc(100% + 2rem);
  }
`, MenuWrapper = styled(Flex)`
  margin: -0.5rem;

  [data-hovered]:not([data-menu-open]) & {
    pointer-events: all;
  }
`, Tab = styled(Flex)`
  bottom: 100%;
  cursor: pointer;
  pointer-events: none;
  position: absolute;
  left: 0;

  [data-hovered]:not([data-menu-open]) & {
    pointer-events: all;
  }

  [data-flipped] & {
    bottom: auto;
    top: 100%;
  }
`, ActionOpen = styled(Card)`
  cursor: pointer;
  background-color: var(--card-focus-ring-color);
  right: 0;
  border-radius: 3px;

  & [data-ui='Text'] {
    color: #fff;
    white-space: nowrap;
  }
`, Labels = styled(Flex)`
  display: flex;
  align-items: center;
  background-color: var(--card-focus-ring-color);
  right: 0;
  border-radius: 3px;
  & [data-ui='Text'],
  & [data-sanity-icon] {
    color: #fff;
    white-space: nowrap;
  }
`, ExclusivePluginContainer = styled.div`
  position: absolute;
  inset: 0;
  pointer-events: all;
`;
function createIntentLink(node) {
  const {
    id,
    type,
    path,
    baseUrl,
    tool,
    workspace
  } = node;
  return createEditUrl({
    baseUrl,
    workspace,
    tool,
    type,
    id,
    path: path ? pathToUrlString(studioPath.fromString(path)) : []
  });
}
const ElementOverlayInner = (props) => {
  const $ = c(59), {
    id,
    element,
    focused,
    componentResolver,
    node,
    showActions,
    draggable,
    targets,
    elementType,
    comlink,
    onActivateExclusivePlugin,
    onMenuOpenChange
  } = props, {
    getField,
    getType
  } = useSchema();
  let t0;
  $[0] !== getType || $[1] !== node ? (t0 = getType(node), $[0] = getType, $[1] = node, $[2] = t0) : t0 = $[2];
  const schemaType = t0;
  let t1;
  $[3] !== node ? (t1 = "path" in node ? createIntentLink(node) : node.href, $[3] = node, $[4] = t1) : t1 = $[4];
  const href = t1, previewSnapshots = usePreviewSnapshots();
  let t2;
  bb0: {
    if (!("path" in node)) {
      t2 = void 0;
      break bb0;
    }
    let t32;
    $[5] !== node || $[6] !== previewSnapshots ? (t32 = previewSnapshots.find((snapshot) => snapshot._id === node.id)?.title, $[5] = node, $[6] = previewSnapshots, $[7] = t32) : t32 = $[7], t2 = t32;
  }
  const title = t2;
  let t3, t4;
  $[8] !== element || $[9] !== focused || $[10] !== getField || $[11] !== getType ? (t4 = function(node_0, nodeElement) {
    const schemaType_0 = getType(node_0), {
      field,
      parent
    } = getField(node_0);
    if (!("id" in node_0) || !field || !schemaType_0)
      return;
    const type = field.value.type;
    return {
      document: schemaType_0,
      element,
      targetElement: nodeElement || element,
      field,
      focused: !!focused,
      node: node_0,
      parent,
      type
    };
  }, $[8] = element, $[9] = focused, $[10] = getField, $[11] = getType, $[12] = t4) : t4 = $[12];
  const getContext = t4;
  let t5;
  $[13] !== elementType || $[14] !== getContext || $[15] !== node ? (t5 = elementType === "element" ? getContext(node) : void 0, $[13] = elementType, $[14] = getContext, $[15] = node, $[16] = t5) : t5 = $[16];
  let t6;
  if ($[17] !== getContext || $[18] !== targets) {
    let t72;
    $[20] !== getContext ? (t72 = (target) => getContext(target.sanity, target.element), $[20] = getContext, $[21] = t72) : t72 = $[21], t6 = targets.map(t72).filter(_temp$8), $[17] = getContext, $[18] = targets, $[19] = t6;
  } else
    t6 = $[19];
  let t7;
  $[22] !== t5 || $[23] !== t6 ? (t7 = {
    legacyComponentContext: t5,
    pluginContexts: t6
  }, $[22] = t5, $[23] = t6, $[24] = t7) : t7 = $[24], t3 = t7;
  const resolverContexts = t3, customComponents = useCustomComponents(resolverContexts.legacyComponentContext, componentResolver), nodePluginCollections = useResolvedNodePlugins(resolverContexts.pluginContexts, props.plugins);
  let t8;
  $[25] !== schemaType ? (t8 = schemaType?.icon ? /* @__PURE__ */ jsx("div", { dangerouslySetInnerHTML: {
    __html: schemaType.icon
  } }) : /* @__PURE__ */ jsx(DocumentIcon, {}), $[25] = schemaType, $[26] = t8) : t8 = $[26];
  const icon = t8, menuId = useId();
  let t9;
  $[27] !== nodePluginCollections ? (t9 = nodePluginCollections?.some(_temp2$5), $[27] = nodePluginCollections, $[28] = t9) : t9 = $[28];
  const showMenu = t9 || nodePluginCollections?.length > 1;
  let t10;
  $[29] !== id ? (t10 = () => {
    window.dispatchEvent(new CustomEvent("sanity-overlay/label-click", {
      detail: {
        id
      }
    }));
  }, $[29] = id, $[30] = t10) : t10 = $[30];
  const handleLabelClick = t10;
  let t11;
  $[31] !== href || $[32] !== showActions ? (t11 = showActions ? /* @__PURE__ */ jsx(Actions, { gap: 1, paddingY: 1, children: /* @__PURE__ */ jsx(Link, { href }) }) : null, $[31] = href, $[32] = showActions, $[33] = t11) : t11 = $[33];
  let t12;
  $[34] !== comlink || $[35] !== draggable || $[36] !== handleLabelClick || $[37] !== icon || $[38] !== menuId || $[39] !== nodePluginCollections || $[40] !== onActivateExclusivePlugin || $[41] !== onMenuOpenChange || $[42] !== showMenu || $[43] !== title ? (t12 = (title || showMenu) && /* @__PURE__ */ jsx(Tab, { gap: 1, paddingY: 1, onClick: handleLabelClick, children: /* @__PURE__ */ jsxs(Labels, { gap: 2, padding: 2, children: [
    draggable && /* @__PURE__ */ jsx(Box, { marginRight: 1, children: /* @__PURE__ */ jsx(Text, { className: "drag-handle", size: 0, children: /* @__PURE__ */ jsx(DragHandleIcon, {}) }) }),
    /* @__PURE__ */ jsx(Text, { size: 0, children: icon }),
    title && /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: title }),
    showMenu && /* @__PURE__ */ jsx(Box, { paddingLeft: 2, onClick: _temp3$2, children: /* @__PURE__ */ jsx(MenuWrapper, { children: /* @__PURE__ */ jsx(MenuButton, { id: menuId, popover: {
      animate: !0,
      placement: "bottom-start",
      constrainSize: !0,
      tone: "default"
    }, onOpen: () => {
      onMenuOpenChange?.(!0);
    }, onClose: () => {
      onMenuOpenChange?.(!1);
    }, button: /* @__PURE__ */ jsx(Button, { icon: EllipsisVerticalIcon, tone: "primary", padding: 2 }), menu: /* @__PURE__ */ jsx(Menu, { paddingY: 0, children: /* @__PURE__ */ jsx(PointerEvents, { children: nodePluginCollections?.map((nodePluginCollection_0, index) => /* @__PURE__ */ jsxs(Fragment$1, { children: [
      /* @__PURE__ */ jsxs(Stack, { role: "group", paddingY: 1, space: 0, children: [
        /* @__PURE__ */ jsx(MenuItem, { paddingY: 2, text: /* @__PURE__ */ jsx(Box, { paddingY: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, style: {
          textTransform: "capitalize"
        }, children: `${nodePluginCollection_0.context.document.name}: ${nodePluginCollection_0.context.field?.name}` }) }), onClick: () => {
          nodePluginCollection_0.context.node && comlink?.post("visual-editing/focus", nodePluginCollection_0.context.node);
        } }),
        nodePluginCollection_0.exclusive.map((exclusive) => exclusive.component ? /* @__PURE__ */ jsx(MenuItem, { paddingY: 2, icon: exclusive.icon || /* @__PURE__ */ jsx(PlugIcon, {}), text: /* @__PURE__ */ jsx(Box, { paddingY: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, children: exclusive.title || exclusive.name }) }), onClick: () => onActivateExclusivePlugin?.(exclusive, nodePluginCollection_0.context) }, exclusive.name) : null)
      ] }),
      index < nodePluginCollections.length - 1 && /* @__PURE__ */ jsx(MenuDivider$1, {})
    ] }, nodePluginCollection_0.id)) }) }) }) }) })
  ] }) }), $[34] = comlink, $[35] = draggable, $[36] = handleLabelClick, $[37] = icon, $[38] = menuId, $[39] = nodePluginCollections, $[40] = onActivateExclusivePlugin, $[41] = onMenuOpenChange, $[42] = showMenu, $[43] = title, $[44] = t12) : t12 = $[44];
  let t13;
  $[45] !== nodePluginCollections ? (t13 = nodePluginCollections?.map(_temp4$1), $[45] = nodePluginCollections, $[46] = t13) : t13 = $[46];
  let t14;
  $[47] !== t13 ? (t14 = /* @__PURE__ */ jsx(HUD, { children: t13 }), $[47] = t13, $[48] = t14) : t14 = $[48];
  let t15;
  $[49] !== t11 || $[50] !== t12 || $[51] !== t14 ? (t15 = /* @__PURE__ */ jsxs(PointerEvents, { children: [
    t11,
    t12,
    t14
  ] }), $[49] = t11, $[50] = t12, $[51] = t14, $[52] = t15) : t15 = $[52];
  let t16;
  $[53] !== customComponents || $[54] !== resolverContexts.legacyComponentContext ? (t16 = Array.isArray(customComponents) ? customComponents.map((t172, i) => {
    const {
      component: Component_1,
      props: props_0
    } = t172;
    return /* @__PURE__ */ jsx(Component_1, { PointerEvents, ...resolverContexts.legacyComponentContext, ...props_0 }, i);
  }) : customComponents, $[53] = customComponents, $[54] = resolverContexts.legacyComponentContext, $[55] = t16) : t16 = $[55];
  let t17;
  return $[56] !== t15 || $[57] !== t16 ? (t17 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t15,
    t16
  ] }), $[56] = t15, $[57] = t16, $[58] = t17) : t17 = $[58], t17;
}, ElementOverlay = memo(function(props) {
  const $ = c(38), {
    draggable,
    focused,
    hovered,
    rect,
    wasMaybeCollapsed,
    enableScrollIntoView
  } = props, ref = useRef(null), scrolledIntoViewRef = useRef(!1);
  let t0;
  const t1 = `${rect.w}px`, t2 = `${rect.h}px`, t3 = `translate(${rect.x}px, ${rect.y}px)`;
  let t4;
  $[0] !== t1 || $[1] !== t2 || $[2] !== t3 ? (t4 = {
    width: t1,
    height: t2,
    transform: t3
  }, $[0] = t1, $[1] = t2, $[2] = t3, $[3] = t4) : t4 = $[3], t0 = t4;
  const style = t0;
  let t5, t6;
  $[4] !== enableScrollIntoView || $[5] !== focused || $[6] !== wasMaybeCollapsed ? (t5 = () => {
    if (!scrolledIntoViewRef.current && !wasMaybeCollapsed && focused === !0 && ref.current && enableScrollIntoView) {
      const target = ref.current;
      scrollIntoView(ref.current, {
        behavior: (actions) => {
          actions.length !== 0 && target.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "nearest"
          });
        },
        scrollMode: "if-needed",
        block: "center",
        inline: "nearest"
      });
    }
    scrolledIntoViewRef.current = focused === !0;
  }, t6 = [focused, wasMaybeCollapsed, enableScrollIntoView], $[4] = enableScrollIntoView, $[5] = focused, $[6] = wasMaybeCollapsed, $[7] = t5, $[8] = t6) : (t5 = $[7], t6 = $[8]), useEffect(t5, t6);
  const [isNearTop, setIsNearTop] = useState(!1);
  let t7;
  $[9] !== hovered ? (t7 = () => {
    if (!ref.current || !hovered)
      return;
    const io = new IntersectionObserver((t82) => {
      const [intersection] = t82;
      setIsNearTop(intersection.boundingClientRect.top < 0);
    }, {
      threshold: 1
    });
    return io.observe(ref.current), () => io.disconnect();
  }, $[9] = hovered, $[10] = t7) : t7 = $[10];
  let t8;
  $[11] !== hovered || $[12] !== isNearTop ? (t8 = [hovered, isNearTop], $[11] = hovered, $[12] = isNearTop, $[13] = t8) : t8 = $[13], useEffect(t7, t8);
  const [activeExclusivePlugin, setActiveExclusivePlugin] = useState(null);
  let t9;
  $[14] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => {
    setActiveExclusivePlugin(null), window.dispatchEvent(new CustomEvent("sanity-overlay/exclusive-plugin-closed"));
  }, $[14] = t9) : t9 = $[14];
  const closeExclusivePluginView = t9;
  let t10;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (plugin, context) => {
    setActiveExclusivePlugin({
      plugin,
      context
    });
  }, $[15] = t10) : t10 = $[15];
  const onActivateExclusivePlugin = t10, handleExclusivePluginClick = _temp5$1, ExclusivePluginComponent = activeExclusivePlugin?.plugin.component, [menuOpen, setMenuOpen] = useState(!1);
  let t11;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t11 = () => {
    setMenuOpen(!1);
  }, $[16] = t11) : t11 = $[16];
  let t12;
  $[17] !== hovered ? (t12 = [hovered], $[17] = hovered, $[18] = t12) : t12 = $[18], useEffect(t11, t12);
  let t13;
  $[19] !== ExclusivePluginComponent || $[20] !== menuOpen ? (t13 = menuOpen || ExclusivePluginComponent ? /* @__PURE__ */ jsx(PopoverBackground, { onDismiss: closeExclusivePluginView, blockScroll: menuOpen }) : null, $[19] = ExclusivePluginComponent, $[20] = menuOpen, $[21] = t13) : t13 = $[21];
  const t14 = focused ? "" : void 0, t15 = hovered ? "" : void 0, t16 = isNearTop ? "" : void 0, t17 = draggable ? "" : void 0, t18 = menuOpen ? "" : void 0;
  let t19;
  $[22] !== ExclusivePluginComponent || $[23] !== activeExclusivePlugin || $[24] !== hovered || $[25] !== props ? (t19 = ExclusivePluginComponent ? /* @__PURE__ */ jsx(ExclusivePluginContainer, { "data-sanity-overlay-element": !0, onClick: handleExclusivePluginClick, children: /* @__PURE__ */ jsx(ExclusivePluginComponent, { ...activeExclusivePlugin.context, closeExclusiveView: closeExclusivePluginView }) }) : hovered ? /* @__PURE__ */ jsx(ElementOverlayInner, { ...props, onActivateExclusivePlugin, onMenuOpenChange: setMenuOpen }) : null, $[22] = ExclusivePluginComponent, $[23] = activeExclusivePlugin, $[24] = hovered, $[25] = props, $[26] = t19) : t19 = $[26];
  let t20;
  $[27] !== style || $[28] !== t14 || $[29] !== t15 || $[30] !== t16 || $[31] !== t17 || $[32] !== t18 || $[33] !== t19 ? (t20 = /* @__PURE__ */ jsx(Root$3, { "data-focused": t14, "data-hovered": t15, "data-flipped": t16, "data-draggable": t17, "data-menu-open": t18, ref, style, children: t19 }), $[27] = style, $[28] = t14, $[29] = t15, $[30] = t16, $[31] = t17, $[32] = t18, $[33] = t19, $[34] = t20) : t20 = $[34];
  let t21;
  return $[35] !== t13 || $[36] !== t20 ? (t21 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t13,
    t20
  ] }), $[35] = t13, $[36] = t20, $[37] = t21) : t21 = $[37], t21;
});
function useResolvedNodePlugins(componentContexts, plugins) {
  const $ = c(5);
  let t0, t1;
  if ($[0] !== componentContexts || $[1] !== plugins) {
    let t2;
    $[3] !== plugins ? (t2 = (componentContext) => {
      const instance = {
        id: v4(),
        context: componentContext,
        hud: [],
        exclusive: []
      };
      return plugins?.forEach((plugin) => {
        plugin.guard?.(componentContext) && (plugin.type === "hud" && instance.hud.push(plugin), plugin.type === "exclusive" && instance.exclusive.push(plugin));
      }), instance;
    }, $[3] = plugins, $[4] = t2) : t2 = $[4], t1 = componentContexts.map(t2), $[0] = componentContexts, $[1] = plugins, $[2] = t1;
  } else
    t1 = $[2];
  return t0 = t1, t0;
}
function useCustomComponents(componentContext, componentResolver) {
  const $ = c(4);
  let t0;
  bb0: {
    if (!componentContext) {
      t0 = void 0;
      break bb0;
    }
    let t1;
    if ($[0] !== componentContext || $[1] !== componentResolver) {
      const resolved = componentResolver?.(componentContext);
      if (!resolved) {
        t0 = void 0;
        break bb0;
      }
      if (isReactElementOverlayComponent(resolved)) {
        t0 = resolved;
        break bb0;
      }
      t1 = (Array.isArray(resolved) ? resolved : [resolved]).map(_temp6$1), $[0] = componentContext, $[1] = componentResolver, $[2] = t1, $[3] = t0;
    } else
      t1 = $[2], t0 = $[3];
    t0 = t1;
  }
  return t0;
}
function _temp6$1(component) {
  return typeof component == "object" && "component" in component ? component : {
    component,
    props: {}
  };
}
const Link = memo(function(props) {
  const $ = c(6), referer = useSyncExternalStore(_temp7$1, _temp8$1);
  let t0, t1;
  $[0] !== props.href || $[1] !== referer ? (t1 = getLinkHref(props.href, referer), $[0] = props.href, $[1] = referer, $[2] = t1) : t1 = $[2], t0 = t1;
  const href = t0;
  let t2;
  $[3] === Symbol.for("react.memo_cache_sentinel") ? (t2 = /* @__PURE__ */ jsx(ActionOpen, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: "Open in Studio" }) }), $[3] = t2) : t2 = $[3];
  let t3;
  return $[4] !== href ? (t3 = /* @__PURE__ */ jsx(Box, { as: "a", href, target: "_blank", rel: "noopener noreferrer", children: t2 }), $[4] = href, $[5] = t3) : t3 = $[5], t3;
});
function _temp$8(ctx) {
  return ctx !== void 0;
}
function _temp2$5(nodePluginCollection) {
  return nodePluginCollection.exclusive.length > 0;
}
function _temp3$2(e) {
  e.stopPropagation();
}
function _temp4$1(nodePluginCollection_1) {
  return /* @__PURE__ */ jsx(Fragment$1, { children: nodePluginCollection_1.hud.map((hud) => {
    const Component_0 = hud.component;
    return Component_0 ? /* @__PURE__ */ jsx(Component_0, { ...nodePluginCollection_1.context }, hud.name) : null;
  }) }, nodePluginCollection_1.id);
}
function _temp5$1(event) {
  event.stopPropagation();
}
function _temp7$1(onStoreChange) {
  const handlePopState = () => onStoreChange();
  return window.addEventListener("popstate", handlePopState), () => window.removeEventListener("popstate", handlePopState);
}
function _temp8$1() {
  return window.location.href;
}
const OverlayDragGroupRect = (t0) => {
  const $ = c(5), {
    dragGroupRect
  } = t0, t1 = `${dragGroupRect.y}px`, t2 = `${dragGroupRect.x}px`, t3 = `${dragGroupRect.w - 1}px`, t4 = `${dragGroupRect.h - 1}px`;
  let t5;
  return $[0] !== t1 || $[1] !== t2 || $[2] !== t3 || $[3] !== t4 ? (t5 = /* @__PURE__ */ jsx("div", { style: {
    position: "absolute",
    top: t1,
    left: t2,
    width: t3,
    height: t4,
    border: "1px dashed #f0709b",
    pointerEvents: "none"
  } }), $[0] = t1, $[1] = t2, $[2] = t3, $[3] = t4, $[4] = t5) : t5 = $[4], t5;
}, markerThickness = 6;
function lerp(v0, v1, t) {
  return v0 * (1 - t) + v1 * t;
}
const OverlayDragInsertMarker = (t0) => {
  const $ = c(4), {
    dragInsertPosition
  } = t0;
  if (dragInsertPosition === null)
    return;
  const flow = dragInsertPosition?.left || dragInsertPosition?.right ? "horizontal" : "vertical";
  let x = 0, y = 0, width = 0, height = 0;
  if (flow === "horizontal") {
    const {
      left,
      right
    } = dragInsertPosition;
    if (width = markerThickness, right && left) {
      const startX = left.rect.x + left.rect.w, endX = right.rect.x, offset = Math.min(right.rect.h, left.rect.h) * 0.0125;
      x = lerp(startX, endX, 0.5) - markerThickness / 2, y = left.rect.y + offset, height = Math.min(right.rect.h, left.rect.h) - offset * 2;
    } else if (right && !left) {
      const offset_0 = right.rect.h * 0.0125;
      x = right.rect.x - markerThickness / 2, y = right.rect.y + offset_0, height = right.rect.h - offset_0 * 2;
    } else if (left && !right) {
      const offset_1 = left.rect.h * 0.0125;
      x = left.rect.x + left.rect.w - markerThickness / 2, y = left.rect.y + offset_1, height = left.rect.h - offset_1 * 2;
    }
  } else {
    const {
      bottom,
      top
    } = dragInsertPosition;
    if (bottom && top) {
      const startX_0 = Math.min(top.rect.x, bottom.rect.x), startY = top.rect.y + top.rect.h, endY = bottom.rect.y, offset_2 = Math.min(bottom.rect.w, top.rect.w) * 0.0125;
      height = markerThickness, x = startX_0 + offset_2, y = lerp(startY, endY, 0.5) - markerThickness / 2, width = Math.max(bottom.rect.w, top.rect.w) - offset_2 * 2;
    } else if (bottom && !top) {
      const offset_3 = bottom.rect.w * 0.0125;
      x = bottom.rect.x + offset_3, y = bottom.rect.y - markerThickness / 2, width = bottom.rect.w - offset_3 * 2, height = markerThickness;
    } else if (top && !bottom) {
      const offset_4 = top.rect.w * 0.0125;
      x = top.rect.x + offset_4, y = top.rect.y + top.rect.h - markerThickness / 2, width = top.rect.w - offset_4 * 2, height = markerThickness;
    }
  }
  const t1 = `${width}px`, t2 = `${height}px`, t3 = `translate(${x}px, ${y}px)`;
  let t4;
  return $[0] !== t1 || $[1] !== t2 || $[2] !== t3 ? (t4 = /* @__PURE__ */ jsx("div", { style: {
    position: "absolute",
    width: t1,
    height: t2,
    transform: t3,
    background: "#556bfc",
    border: "2px solid white",
    borderRadius: "999px",
    zIndex: "999999"
  } }), $[0] = t1, $[1] = t2, $[2] = t3, $[3] = t4) : t4 = $[3], t4;
}, Root$2 = styled.div`
  --drag-preview-opacity: 0.98;
  --drag-preview-skeleton-stroke: #ffffff;

  @media (prefers-color-scheme: dark) {
    --drag-preview-skeleton-stroke: #383d51;
  }

  position: fixed;
  display: grid;
  transform: ${({
  $scaleFactor,
  $width,
  $height
}) => `translate(calc(var(--drag-preview-x) - ${$width / 2}px), calc(var(--drag-preview-y) - ${$height / 2}px)) scale(${$scaleFactor})`};
  width: ${({
  $width
}) => `${$width}px`};
  height: ${({
  $height
}) => `${$height}px`};
  z-index: 9999999;
  opacity: var(--drag-preview-opacity);
  cursor: move;

  .drag-preview-content-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    container-type: inline-size;
  }

  [data-ui='card'] {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .drag-preview-skeleton {
    position: absolute;
    inset: 0;

    rect {
      stroke: var(--drag-preview-skeleton-stroke);
    }
  }

  .drag-preview-handle {
    position: absolute;
    top: 4cqmin;
    left: 4cqmin;
    width: 6cqmin;
    fill: var(--drag-preview-handle-fill);
  }
`;
function clamp(number, min, max) {
  return number < min ? min : number > max ? max : number;
}
function map(number, inMin, inMax, outMin, outMax) {
  const mapped = (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  return clamp(mapped, outMin, outMax);
}
const OverlayDragPreview = (t0) => {
  const $ = c(50), {
    skeleton
  } = t0, maxSkeletonWidth = Math.min(skeleton.maxWidth, window.innerWidth / 2), scaleFactor = skeleton.w > maxSkeletonWidth ? maxSkeletonWidth / skeleton.w : 1, offsetX = skeleton.offsetX * scaleFactor, offsetY = skeleton.offsetY * scaleFactor, prefersDark = usePrefersDark(), theme = useTheme_v2(), radius = theme.radius[~~map(skeleton.w, 0, 1920, 1, theme.radius.length - 2)];
  let T0, T1, t1, t10, t11, t12, t13, t14, t2, t3, t4, t5, t6, t7, t8, t9;
  if ($[0] !== offsetX || $[1] !== offsetY || $[2] !== prefersDark || $[3] !== radius || $[4] !== scaleFactor || $[5] !== skeleton.childRects || $[6] !== skeleton.h || $[7] !== skeleton.w) {
    const imageRects = skeleton.childRects.filter(_temp$7), textRects = skeleton.childRects.filter(_temp2$4);
    T1 = Root$2, t10 = skeleton.w, t11 = skeleton.h, t12 = offsetX, t13 = offsetY, t14 = scaleFactor, T0 = Card, t5 = radius, t6 = 4, t7 = "hidden", t8 = "transparent", t9 = prefersDark ? "dark" : "light", t4 = "drag-preview-content-wrapper", t2 = "drag-preview-skeleton", t3 = `0 0 ${skeleton.w} ${skeleton.h}`, t1 = [...imageRects, ...textRects], $[0] = offsetX, $[1] = offsetY, $[2] = prefersDark, $[3] = radius, $[4] = scaleFactor, $[5] = skeleton.childRects, $[6] = skeleton.h, $[7] = skeleton.w, $[8] = T0, $[9] = T1, $[10] = t1, $[11] = t10, $[12] = t11, $[13] = t12, $[14] = t13, $[15] = t14, $[16] = t2, $[17] = t3, $[18] = t4, $[19] = t5, $[20] = t6, $[21] = t7, $[22] = t8, $[23] = t9;
  } else
    T0 = $[8], T1 = $[9], t1 = $[10], t10 = $[11], t11 = $[12], t12 = $[13], t13 = $[14], t14 = $[15], t2 = $[16], t3 = $[17], t4 = $[18], t5 = $[19], t6 = $[20], t7 = $[21], t8 = $[22], t9 = $[23];
  let t15;
  $[24] !== t1 || $[25] !== theme.color ? (t15 = t1.map((r_1, i) => /* @__PURE__ */ jsx("rect", { x: r_1.x, y: r_1.y, width: r_1.w, height: r_1.h, fill: theme.color.skeleton.from }, i)), $[24] = t1, $[25] = theme.color, $[26] = t15) : t15 = $[26];
  let t16;
  $[27] !== t15 || $[28] !== t2 || $[29] !== t3 ? (t16 = /* @__PURE__ */ jsx("svg", { className: t2, viewBox: t3, children: t15 }), $[27] = t15, $[28] = t2, $[29] = t3, $[30] = t16) : t16 = $[30];
  let t17;
  $[31] !== t16 || $[32] !== t4 ? (t17 = /* @__PURE__ */ jsx("div", { className: t4, children: t16 }), $[31] = t16, $[32] = t4, $[33] = t17) : t17 = $[33];
  let t18;
  $[34] !== T0 || $[35] !== t17 || $[36] !== t5 || $[37] !== t6 || $[38] !== t7 || $[39] !== t8 || $[40] !== t9 ? (t18 = /* @__PURE__ */ jsx(T0, { radius: t5, shadow: t6, overflow: t7, tone: t8, scheme: t9, children: t17 }), $[34] = T0, $[35] = t17, $[36] = t5, $[37] = t6, $[38] = t7, $[39] = t8, $[40] = t9, $[41] = t18) : t18 = $[41];
  let t19;
  return $[42] !== T1 || $[43] !== t10 || $[44] !== t11 || $[45] !== t12 || $[46] !== t13 || $[47] !== t14 || $[48] !== t18 ? (t19 = /* @__PURE__ */ jsx(T1, { $width: t10, $height: t11, $offsetX: t12, $offsetY: t13, $scaleFactor: t14, children: t18 }), $[42] = T1, $[43] = t10, $[44] = t11, $[45] = t12, $[46] = t13, $[47] = t14, $[48] = t18, $[49] = t19) : t19 = $[49], t19;
};
function _temp$7(r) {
  return r.tagName === "IMG";
}
function _temp2$4(r_0) {
  return r_0.tagName !== "IMG";
}
const Root$1 = styled(Card)`
  position: fixed;
  bottom: 2rem;
  left: 2rem;
`, OverlayMinimapPrompt = () => {
  const $ = c(2);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    zIndex: "999999"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsx(Root$1, { padding: 2, shadow: 2, radius: 2, style: t0, children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 2, children: [
    /* @__PURE__ */ jsx(Hotkeys, { keys: ["Shift"] }),
    /* @__PURE__ */ jsx(Text, { size: 1, children: "Zoom Out" }),
    /* @__PURE__ */ jsx(ExpandIcon, {})
  ] }) }), $[1] = t1) : t1 = $[1], t1;
}, elementsReducer = (elements, message) => {
  const {
    type
  } = message;
  switch (type) {
    case "element/register":
      return elements.find((e) => e.id === message.id) ? elements : [...elements, {
        id: message.id,
        activated: !1,
        element: message.element,
        focused: !1,
        hovered: !1,
        rect: message.rect,
        sanity: message.sanity,
        dragDisabled: message.dragDisabled,
        targets: message.targets,
        elementType: message.elementType
      }];
    case "element/activate":
      return elements.map((e) => e.id === message.id ? {
        ...e,
        activated: !0
      } : e);
    case "element/update":
      return elements.map((e) => e.id === message.id ? {
        ...e,
        sanity: message.sanity,
        rect: message.rect,
        targets: message.targets,
        elementType: message.elementType
      } : e);
    case "element/unregister":
      return elements.filter((e) => e.id !== message.id);
    case "element/deactivate":
      return elements.map((e) => e.id === message.id ? {
        ...e,
        activated: !1,
        hovered: !1
      } : e);
    case "element/mouseenter":
      return elements.map((e) => e.id === message.id ? {
        ...e,
        rect: message.rect,
        hovered: !0
      } : {
        ...e,
        hovered: !1
      });
    case "element/mouseleave":
      return elements.map((element) => element.id === message.id ? {
        ...element,
        hovered: !1
      } : element);
    case "element/updateRect":
      return elements.map((element) => element.id === message.id ? {
        ...element,
        rect: message.rect
      } : element);
    case "element/click":
      return elements.map((e) => ({
        ...e,
        focused: e.id === message.id && "clicked"
      }));
    case "overlay/reset-mouse-state":
      return elements.map((e) => ({
        ...e,
        focused: !1,
        hovered: !1
      }));
    case "overlay/blur":
      return elements.map((e) => ({
        ...e,
        focused: !1
      }));
    case "presentation/blur":
      return elements.map((e) => ({
        ...e,
        focused: !1
      }));
    case "presentation/focus": {
      const clickedElement = elements.find((e) => e.focused === "clicked");
      return elements.map((e) => {
        const focused = "path" in e.sanity && e.sanity.id === message.data.id && e.sanity.path === message.data.path;
        return clickedElement && e === clickedElement && focused ? e : {
          ...e,
          // Mark as a dupe if another matching item has been clicked to prevent
          // scrolling, otherwise just set focus as a boolean
          focused: focused && clickedElement ? "duplicate" : focused
        };
      });
    }
    default:
      return elements;
  }
};
function overlayStateReducer(state, message) {
  const {
    type
  } = message;
  let {
    contextMenu,
    focusPath,
    perspective,
    isDragging,
    dragInsertPosition,
    dragShowMinimap,
    dragShowMinimapPrompt,
    dragSkeleton,
    dragMinimapTransition,
    dragGroupRect
  } = state, wasMaybeCollapsed = !1;
  if (type === "presentation/focus") {
    const prevFocusPath = state.focusPath;
    focusPath = message.data.path, prevFocusPath !== focusPath && (wasMaybeCollapsed = prevFocusPath.slice(focusPath.length).startsWith("["));
  }
  return type === "presentation/perspective" && (perspective = message.data.perspective), type === "element/contextmenu" && ("sanity" in message ? contextMenu = {
    node: message.sanity,
    position: message.position
  } : contextMenu = null), (type === "element/click" || type === "element/mouseleave" || type === "overlay/blur" || type === "presentation/blur" || type === "presentation/focus") && (contextMenu = null), type === "overlay/dragUpdateInsertPosition" && (dragInsertPosition = message.insertPosition), type === "overlay/dragStart" && (isDragging = !0), message.type === "overlay/dragUpdateSkeleton" && (dragSkeleton = message.skeleton), type === "overlay/dragEnd" && (isDragging = !1), message.type === "overlay/dragToggleMinimapPrompt" && (dragShowMinimapPrompt = message.display), type === "overlay/dragStartMinimapTransition" && (dragMinimapTransition = !0), type === "overlay/dragEndMinimapTransition" && (dragMinimapTransition = !1), type === "overlay/dragUpdateGroupRect" && (dragGroupRect = message.groupRect), type === "overlay/dragToggleMinimap" && (dragShowMinimap = message.display), {
    ...state,
    contextMenu,
    elements: elementsReducer(state.elements, message),
    dragInsertPosition,
    dragSkeleton,
    dragGroupRect,
    isDragging,
    focusPath,
    perspective,
    wasMaybeCollapsed,
    dragShowMinimap,
    dragShowMinimapPrompt,
    dragMinimapTransition
  };
}
const PreviewSnapshotsProvider = function(props) {
  const $ = c(13), {
    comlink,
    children
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = [], $[0] = t0) : t0 = $[0];
  const [previewSnapshots, setPreviewSnapshots] = useState(t0);
  let t1;
  $[1] !== comlink ? (t1 = async (signal) => {
    if (comlink)
      try {
        const response = await comlink.fetch("visual-editing/preview-snapshots", void 0, {
          signal,
          suppressWarnings: !0
        });
        setPreviewSnapshots(response.snapshots);
      } catch {
      }
  }, $[1] = comlink, $[2] = t1) : t1 = $[2];
  const fetchPreviewSnapshots = t1;
  let t2, t3;
  $[3] !== comlink || $[4] !== fetchPreviewSnapshots ? (t2 = () => {
    if (!comlink)
      return;
    const previewSapshotsFetch = new AbortController(), unsub = comlink.onStatus(() => {
      fetchPreviewSnapshots(previewSapshotsFetch.signal);
    }, "connected");
    return () => {
      previewSapshotsFetch.abort(), unsub();
    };
  }, t3 = [comlink, fetchPreviewSnapshots], $[3] = comlink, $[4] = fetchPreviewSnapshots, $[5] = t2, $[6] = t3) : (t2 = $[5], t3 = $[6]), useEffect(t2, t3);
  let t4, t5;
  $[7] !== comlink ? (t4 = () => comlink?.on("presentation/preview-snapshots", (data) => {
    setPreviewSnapshots(data.snapshots);
  }), t5 = [comlink], $[7] = comlink, $[8] = t4, $[9] = t5) : (t4 = $[8], t5 = $[9]), useEffect(t4, t5);
  let t6;
  t6 = previewSnapshots;
  const context = t6;
  let t7;
  return $[10] !== children || $[11] !== context ? (t7 = /* @__PURE__ */ jsx(PreviewSnapshotsContext.Provider, { value: context, children }), $[10] = children, $[11] = context, $[12] = t7) : t7 = $[12], t7;
};
function isSanityNode(node) {
  return "path" in node;
}
function isDocumentSchemaType(type) {
  return type.type === "document";
}
function isTypeSchemaType(type) {
  return type.type === "type";
}
function popUnkeyedPathSegments(path) {
  return path.split(".").toReversed().reduce((acc, part) => acc.length ? [part, ...acc] : part.includes("[_key==") ? [part] : [], []).join(".");
}
function getPathsWithUnresolvedTypes(elements) {
  return elements.reduce((acc, element) => {
    const {
      sanity
    } = element;
    if (!("id" in sanity) || !sanity.path.includes("[_key==")) return acc;
    const path = popUnkeyedPathSegments(sanity.path);
    return acc.find((item) => item.id === sanity.id && item.path === path) || acc.push({
      id: sanity.id,
      path
    }), acc;
  }, []);
}
const SchemaProvider = function(props) {
  const $ = c(22), {
    comlink,
    children,
    elements
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ new Map(), $[0] = t0) : t0 = $[0];
  const [resolvedTypes, setResolvedTypes] = useState(t0), [schema, setSchema] = useState(null);
  let t1, t2;
  $[1] !== comlink ? (t1 = () => {
    if (!comlink)
      return;
    const fetchSchema = async function(signal) {
      if (comlink)
        try {
          const response = await comlink.fetch("visual-editing/schema", void 0, {
            signal,
            suppressWarnings: !0
          });
          setSchema(response.schema);
        } catch {
        }
    }, schemaFetch = new AbortController(), unsub = comlink.onStatus(() => {
      fetchSchema(schemaFetch.signal);
    }, "connected");
    return () => {
      schemaFetch.abort(), unsub();
    };
  }, t2 = [comlink], $[1] = comlink, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), useEffect(t1, t2);
  let t3;
  $[4] === Symbol.for("react.memo_cache_sentinel") ? (t3 = [], $[4] = t3) : t3 = $[4];
  const reportedPathsRef = useRef(t3), t4 = useDeferredValue(elements);
  let t5;
  $[5] !== t4 ? (t5 = getPathsWithUnresolvedTypes(t4), $[5] = t4, $[6] = t5) : t5 = $[6];
  const paths = t5, controllerRef = useRef(null);
  let t6, t7;
  $[7] !== comlink || $[8] !== paths ? (t6 = () => {
    if (!paths.length || !comlink)
      return;
    const reportPaths = async (paths_0, signal_0) => {
      const initialReportedPaths = reportedPathsRef.current;
      try {
        reportedPathsRef.current = paths_0;
        const response_0 = await comlink.fetch("visual-editing/schema-union-types", {
          paths: paths_0
        }, {
          signal: signal_0,
          suppressWarnings: !0
        });
        if (signal_0.aborted)
          return;
        setResolvedTypes(response_0.types), controllerRef.current = null;
      } catch {
      }
      signal_0.aborted && (reportedPathsRef.current = initialReportedPaths);
    };
    paths.some((p) => !reportedPathsRef.current.find((t82) => {
      const {
        id,
        path
      } = t82;
      return id === p.id && path === p.path;
    })) && (controllerRef.current?.abort(), controllerRef.current = new AbortController(), reportPaths(paths, controllerRef.current.signal));
  }, t7 = [comlink, paths], $[7] = comlink, $[8] = paths, $[9] = t6, $[10] = t7) : (t6 = $[9], t7 = $[10]), useEffect(t6, t7);
  let t8;
  $[11] !== schema ? (t8 = (node, _type) => {
    const type = _type || "document";
    if (!schema || typeof node != "string" && (!isSanityNode(node) || !Array.isArray(schema)))
      return;
    const name = typeof node == "string" ? node : node.type, filter = type === "document" ? isDocumentSchemaType : isTypeSchemaType;
    return schema.filter(filter).find((schemaType) => schemaType.name === name);
  }, $[11] = schema, $[12] = t8) : t8 = $[12];
  const getType = t8;
  let t9;
  $[13] !== getType || $[14] !== resolvedTypes ? (t9 = (node_0) => {
    if (!isSanityNode(node_0))
      return {
        field: void 0,
        parent: void 0
      };
    const schemaType_0 = getType(node_0);
    if (!schemaType_0)
      return {
        field: void 0,
        parent: void 0
      };
    function fieldFromPath(schemaType_1, path_0, parent, t102) {
      const prevPath = t102 === void 0 ? [] : t102;
      if (!schemaType_1)
        return {
          field: void 0,
          parent: void 0
        };
      const [next, ...rest] = path_0;
      if ("fields" in schemaType_1) {
        const objectField = schemaType_1.fields[next];
        if (!objectField && "rest" in schemaType_1)
          return fieldFromPath(schemaType_1.rest, path_0, schemaType_1, prevPath);
        if (!rest.length)
          return {
            field: objectField,
            parent
          };
        if (!objectField)
          throw new Error(`[@sanity/visual-editing] No field could be resolved at path: "${[...prevPath, ...path_0].join(".")}"`);
        return fieldFromPath(objectField.value, rest, schemaType_1, [...prevPath, next]);
      } else {
        if (schemaType_1.type === "array")
          return fieldFromPath(schemaType_1.of, path_0, schemaType_1, prevPath);
        if (schemaType_1.type === "arrayItem")
          return rest.length ? fieldFromPath(schemaType_1.value, rest, schemaType_1, [...prevPath, next]) : {
            field: schemaType_1,
            parent
          };
        if (schemaType_1.type === "union") {
          const name_0 = next.startsWith("[_key==") ? resolvedTypes?.get(node_0.id)?.get([prevPath.join("."), next].filter(Boolean).join("")) : next;
          return fieldFromPath(schemaType_1.of.find((item) => item.type === "unionOption" ? item.name === name_0 : item), rest, schemaType_1, [...prevPath, next]);
        } else {
          if (schemaType_1.type === "unionOption")
            return next ? fieldFromPath(schemaType_1.value, path_0, schemaType_1, prevPath) : {
              field: schemaType_1,
              parent
            };
          if (schemaType_1.type === "inline") {
            const type_0 = getType(schemaType_1.name, "type");
            return fieldFromPath(type_0.value, path_0, schemaType_1, prevPath);
          }
        }
      }
      throw new Error(`[@sanity/visual-editing] No field could be resolved at path: "${[...prevPath, ...path_0].join(".")}"`);
    }
    const nodePath = node_0.path.split(".").flatMap(_temp$6);
    try {
      return fieldFromPath(schemaType_0, nodePath, void 0);
    } catch (t112) {
      const e = t112;
      return e instanceof Error && console.warn(e.message), {
        field: void 0,
        parent: void 0
      };
    }
  }, $[13] = getType, $[14] = resolvedTypes, $[15] = t9) : t9 = $[15];
  const getField = t9;
  let t10, t11;
  $[16] !== getField || $[17] !== getType ? (t11 = {
    getField,
    getType
  }, $[16] = getField, $[17] = getType, $[18] = t11) : t11 = $[18], t10 = t11;
  const context = t10;
  let t12;
  return $[19] !== children || $[20] !== context ? (t12 = /* @__PURE__ */ jsx(SchemaContext.Provider, { value: context, children }), $[19] = children, $[20] = context, $[21] = t12) : t12 = $[21], t12;
};
function _temp$6(part) {
  return part.includes("[") ? part.split(/(\[.+\])/, 2) : [part];
}
const createStore = (initialState) => {
  let state = initialState;
  const getState = () => state, listeners = /* @__PURE__ */ new Set();
  return {
    getState,
    setState: (fn) => {
      state = fn(state), listeners.forEach((l) => l());
    },
    subscribe: (listener) => (listeners.add(listener), () => listeners.delete(listener))
  };
}, store = createStore({}), SharedStateProvider = (props) => {
  const $ = c(11), {
    comlink,
    children
  } = props;
  let t0, t1;
  $[0] !== comlink ? (t0 = () => comlink?.on("presentation/shared-state", _temp$5), t1 = [comlink], $[0] = comlink, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
  let t2, t3;
  $[3] !== comlink ? (t2 = () => {
    (async function() {
      const value = await comlink?.fetch("visual-editing/shared-state", void 0, {
        suppressWarnings: !0
      });
      value && store.setState(() => value.state);
    })().catch(_temp2$3);
  }, t3 = [comlink], $[3] = comlink, $[4] = t2, $[5] = t3) : (t2 = $[4], t3 = $[5]), useEffect(t2, t3);
  let t4, t5;
  $[6] !== comlink ? (t5 = {
    comlink,
    store
  }, $[6] = comlink, $[7] = t5) : t5 = $[7], t4 = t5;
  const value_0 = t4;
  let t6;
  return $[8] !== children || $[9] !== value_0 ? (t6 = /* @__PURE__ */ jsx(SharedStateContext.Provider, { value: value_0, children }), $[8] = children, $[9] = value_0, $[10] = t6) : t6 = $[10], t6;
};
function _temp$5(data) {
  "value" in data ? store.setState((prev) => ({
    ...prev,
    [data.key]: data.value
  })) : store.setState((prev_0) => Object.fromEntries(Object.entries(prev_0).filter((t0) => {
    const [key] = t0;
    return key !== data.key;
  })));
}
function _temp2$3(reason) {
  console.debug(reason), console.warn("[@sanity/visual-editing]: Failed to fetch shared state. Check your version of `sanity` is up-to-date");
}
const TelemetryProvider = (t0) => {
  const $ = c(5), {
    children,
    comlink
  } = t0;
  let t1;
  $[0] !== comlink ? (t1 = (name, data) => {
    if (!comlink)
      return;
    const event = events[name];
    if (event)
      comlink.post("visual-editing/telemetry-log", {
        event,
        data
      });
    else
      throw new Error(`Telemetry event: ${name} does not exist`);
  }, $[0] = comlink, $[1] = t1) : t1 = $[1];
  const log = t1;
  let t2;
  return $[2] !== children || $[3] !== log ? (t2 = /* @__PURE__ */ jsx(TelemetryContext.Provider, { value: log, children }), $[2] = children, $[3] = log, $[4] = t2) : t2 = $[4], t2;
};
function useController(element, handler, inFrame, inPopUp) {
  const $ = c(7), overlayController = useRef(void 0), optimisticActorReady = useOptimisticActorReady();
  let t0, t1;
  return $[0] !== element || $[1] !== handler || $[2] !== inFrame || $[3] !== inPopUp || $[4] !== optimisticActorReady ? (t0 = () => {
    if (element)
      return overlayController.current = createOverlayController({
        handler,
        overlayElement: element,
        inFrame,
        inPopUp,
        optimisticActorReady
      }), () => {
        overlayController.current?.destroy(), overlayController.current = void 0;
      };
  }, t1 = [element, handler, inFrame, inPopUp, optimisticActorReady], $[0] = element, $[1] = handler, $[2] = inFrame, $[3] = inPopUp, $[4] = optimisticActorReady, $[5] = t0, $[6] = t1) : (t0 = $[5], t1 = $[6]), useEffect(t0, t1), overlayController;
}
function usePerspectiveSync(comlink, dispatch) {
  const $ = c(4);
  let t0, t1;
  $[0] !== comlink || $[1] !== dispatch ? (t0 = () => {
    const controller = new AbortController();
    comlink?.fetch("visual-editing/fetch-perspective", void 0, {
      signal: controller.signal,
      suppressWarnings: !0
    }).then((data) => {
      dispatch({
        type: "presentation/perspective",
        data
      });
    }).catch(_temp$4);
    const unsub = comlink?.on("presentation/perspective", (data_0) => {
      dispatch({
        type: "presentation/perspective",
        data: data_0
      });
    });
    return () => {
      unsub?.(), controller.abort();
    };
  }, t1 = [comlink, dispatch], $[0] = comlink, $[1] = dispatch, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), useEffect(t0, t1);
}
function _temp$4() {
}
function isEqualSets(a, b) {
  if (a === b) return !0;
  if (a.size !== b.size) return !1;
  for (const value of a) if (!b.has(value)) return !1;
  return !0;
}
function useReportDocuments(comlink, elements, perspective) {
  const $ = c(7), lastReported = useRef(void 0);
  let t0;
  $[0] !== comlink ? (t0 = (documents, perspective_0) => {
    comlink?.post("visual-editing/documents", {
      documents,
      perspective: perspective_0
    });
  }, $[0] = comlink, $[1] = t0) : t0 = $[1];
  const reportDocuments = t0;
  let t1, t2;
  $[2] !== elements || $[3] !== perspective || $[4] !== reportDocuments ? (t1 = () => {
    const nodes = elements.map(_temp$3).filter(_temp2$2), nodeIds = new Set(nodes.map(_temp3$1));
    if (!lastReported.current || !isEqualSets(nodeIds, lastReported.current.nodeIds) || perspective !== lastReported.current.perspective) {
      const documentsOnPage = Array.from(nodeIds).map((_id) => {
        const node_0 = nodes.find((node) => node.id === _id), {
          type,
          projectId: _projectId,
          dataset: _dataset
        } = node_0;
        return _projectId && _dataset ? {
          _id,
          _type: type,
          _projectId,
          _dataset
        } : {
          _id,
          _type: type
        };
      });
      lastReported.current = {
        nodeIds,
        perspective
      }, reportDocuments(documentsOnPage, perspective);
    }
  }, t2 = [elements, perspective, reportDocuments], $[2] = elements, $[3] = perspective, $[4] = reportDocuments, $[5] = t1, $[6] = t2) : (t1 = $[5], t2 = $[6]), useEffect(t1, t2);
}
function _temp3$1(e_0) {
  return e_0.id;
}
function _temp2$2(s) {
  return !!s;
}
function _temp$3(e) {
  const {
    sanity
  } = e;
  return !sanity || !("id" in sanity) ? null : sanity;
}
const Root = styled.div`
  background-color: transparent;
  direction: ltr;
  inset: 0;
  pointer-events: none;
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: ${({
  $zIndex
}) => $zIndex ?? "9999999"};
`;
function raf2(fn) {
  let r0, r1;
  return r0 = requestAnimationFrame(() => {
    r1 = requestAnimationFrame(fn);
  }), () => {
    r0 !== void 0 && cancelAnimationFrame(r0), r1 !== void 0 && cancelAnimationFrame(r1);
  };
}
const DocumentReporter = (props) => {
  const $ = c(8), {
    documentIds
  } = props;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = [], $[0] = t0) : t0 = $[0];
  const [uniqueIds, setUniqueIds] = useState(t0);
  let t1, t2;
  $[1] !== documentIds ? (t1 = () => {
    setUniqueIds((prev) => {
      const next = Array.from(new Set(documentIds));
      return prev.length === next.length && prev.reduce(_temp$2, next)?.length === 0 ? prev : next;
    });
  }, t2 = [documentIds], $[1] = documentIds, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), useEffect(t1, t2);
  const actor = useOptimisticActor();
  let t3, t4;
  return $[4] !== actor || $[5] !== uniqueIds ? (t3 = () => {
    for (const id_0 of uniqueIds)
      actor.send({
        type: "observe",
        documentId: getDraftId(id_0)
      }), actor.send({
        type: "observe",
        documentId: getPublishedId(id_0)
      });
    return () => {
      for (const id_1 of uniqueIds)
        actor.send({
          type: "unobserve",
          documentId: getDraftId(id_1)
        }), actor.send({
          type: "unobserve",
          documentId: getPublishedId(id_1)
        });
    };
  }, t4 = [actor, uniqueIds], $[4] = actor, $[5] = uniqueIds, $[6] = t3, $[7] = t4) : (t3 = $[6], t4 = $[7]), useEffect(t3, t4), null;
}, OverlaysController = (props) => {
  const $ = c(12), {
    comlink,
    dispatch,
    inFrame,
    inPopUp,
    onDrag,
    overlayEnabled,
    rootElement
  } = props, {
    dispatchDragEndEvent
  } = useDragEndEvents(), sendTelemetry = useTelemetry();
  let t0;
  $[0] !== comlink || $[1] !== dispatch || $[2] !== dispatchDragEndEvent || $[3] !== onDrag || $[4] !== sendTelemetry ? (t0 = (message) => {
    if (message.type === "element/click") {
      const {
        sanity
      } = message;
      comlink?.post("visual-editing/focus", sanity), sendTelemetry("Visual Editing Overlay Clicked", null);
    } else if (message.type === "overlay/activate")
      comlink?.post("visual-editing/toggle", {
        enabled: !0
      });
    else if (message.type === "overlay/deactivate")
      comlink?.post("visual-editing/toggle", {
        enabled: !1
      });
    else if (message.type === "overlay/dragEnd") {
      const {
        insertPosition,
        target,
        dragGroup,
        flow,
        preventInsertDefault
      } = message;
      dispatchDragEndEvent({
        insertPosition,
        target,
        dragGroup,
        flow,
        preventInsertDefault
      }), insertPosition && sendTelemetry("Visual Editing Drag Sequence Completed", null);
    } else if (message.type === "overlay/dragUpdateCursorPosition") {
      onDrag(message.x, message.y);
      return;
    } else if (message.type === "overlay/dragToggleMinimap" && message.display === !0)
      sendTelemetry("Visual Editing Drag Minimap Enabled", null);
    else if (message.type === "overlay/setCursor") {
      const {
        element,
        cursor
      } = message;
      cursor ? element.style.cursor = cursor : element.style.removeProperty("cursor");
    }
    dispatch(message);
  }, $[0] = comlink, $[1] = dispatch, $[2] = dispatchDragEndEvent, $[3] = onDrag, $[4] = sendTelemetry, $[5] = t0) : t0 = $[5];
  const controller = useController(rootElement, t0, inFrame, inPopUp);
  let t1;
  $[6] !== controller.current || $[7] !== overlayEnabled ? (t1 = () => {
    overlayEnabled ? controller.current?.activate() : controller.current?.deactivate();
  }, $[6] = controller.current, $[7] = overlayEnabled, $[8] = t1) : t1 = $[8];
  let t2;
  return $[9] !== controller || $[10] !== overlayEnabled ? (t2 = [controller, overlayEnabled], $[9] = controller, $[10] = overlayEnabled, $[11] = t2) : t2 = $[11], useEffect(t1, t2), null;
}, Overlays = (props) => {
  const $ = c(76), {
    comlink,
    comlinkStatus,
    componentResolver: _componentResolver,
    inFrame,
    inPopUp,
    zIndex
  } = props, prefersDark = usePrefersDark();
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    contextMenu: null,
    dragInsertPosition: null,
    dragShowMinimap: !1,
    dragShowMinimapPrompt: !1,
    dragSkeleton: null,
    elements: [],
    focusPath: "",
    isDragging: !1,
    perspective: "published",
    wasMaybeCollapsed: !1,
    dragMinimapTransition: !1,
    dragGroupRect: null
  }, $[0] = t0) : t0 = $[0];
  const [t1, dispatch] = useReducer(overlayStateReducer, t0), {
    contextMenu,
    dragInsertPosition,
    dragShowMinimap,
    dragShowMinimapPrompt,
    dragSkeleton,
    elements,
    isDragging,
    perspective,
    wasMaybeCollapsed,
    dragMinimapTransition,
    dragGroupRect
  } = t1, [rootElement, setRootElement] = useState(null), [overlayEnabled, setOverlayEnabled] = useState(!0);
  let t2, t3;
  $[1] !== comlink ? (t2 = () => {
    const unsubs = [comlink?.on("presentation/focus", (data) => {
      dispatch({
        type: "presentation/focus",
        data
      });
    }), comlink?.on("presentation/blur", (data_0) => {
      dispatch({
        type: "presentation/blur",
        data: data_0
      });
    }), comlink?.on("presentation/toggle-overlay", () => {
      setOverlayEnabled(_temp2$1);
    })].filter(Boolean);
    return () => unsubs.forEach(_temp3);
  }, t3 = [comlink], $[1] = comlink, $[2] = t2, $[3] = t3) : (t2 = $[2], t3 = $[3]), useEffect(t2, t3), usePerspectiveSync(comlink, dispatch), useReportDocuments(comlink, elements, perspective);
  let t4;
  $[4] !== rootElement ? (t4 = (x, y) => {
    rootElement && (rootElement.style.setProperty("--drag-preview-x", `${x}px`), rootElement.style.setProperty("--drag-preview-y", `${y - window.scrollY}px`));
  }, $[4] = rootElement, $[5] = t4) : t4 = $[5];
  const updateDragPreviewCustomProps = t4;
  let t5, t6;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    const handleClick = _temp4, handleKeyUp = (e) => {
      isAltKey(e) && setOverlayEnabled(_temp5);
    }, handleKeydown = (e_0) => {
      isAltKey(e_0) && setOverlayEnabled(_temp6), isHotkey(["mod", "\\"], e_0) && setOverlayEnabled(_temp7);
    };
    return window.addEventListener("click", handleClick), window.addEventListener("keydown", handleKeydown), window.addEventListener("keyup", handleKeyUp), () => {
      window.removeEventListener("click", handleClick), window.removeEventListener("keydown", handleKeydown), window.removeEventListener("keyup", handleKeyUp);
    };
  }, t6 = [setOverlayEnabled], $[6] = t5, $[7] = t6) : (t5 = $[6], t6 = $[7]), useEffect(t5, t6);
  const [overlaysFlash, setOverlaysFlash] = useState(!1), [fadingOut, setFadingOut] = useState(!1), fadeOutTimeoutRef = useRef(void 0);
  let t7, t8;
  $[8] !== overlayEnabled ? (t7 = () => {
    if (overlayEnabled)
      return raf2(() => {
        setOverlaysFlash(!0), raf2(() => {
          setFadingOut(!0), fadeOutTimeoutRef.current = setTimeout(() => {
            setFadingOut(!1), setOverlaysFlash(!1);
          }, 1500);
        });
      });
    fadeOutTimeoutRef.current && (clearTimeout(fadeOutTimeoutRef.current), setOverlaysFlash(!1), setFadingOut(!1));
  }, t8 = [overlayEnabled], $[8] = overlayEnabled, $[9] = t7, $[10] = t8) : (t7 = $[9], t8 = $[10]), useEffect(t7, t8);
  let t9, t10;
  $[11] !== elements ? (t10 = elements.flatMap(_temp8), $[11] = elements, $[12] = t10) : t10 = $[12], t9 = t10;
  const documentIds = t9;
  let t11;
  $[13] === Symbol.for("react.memo_cache_sentinel") ? (t11 = () => {
    dispatch({
      type: "overlay/blur"
    });
  }, $[13] = t11) : t11 = $[13];
  const closeContextMenu = t11, optimisticActorReady = useOptimisticActorReady();
  let t12;
  t12 = optimisticActorReady ? _componentResolver : void 0;
  const componentResolver = t12;
  let t13;
  bb0: {
    if ((inFrame || inPopUp) && comlinkStatus !== "connected" || isDragging) {
      let t143;
      $[14] === Symbol.for("react.memo_cache_sentinel") ? (t143 = [], $[14] = t143) : t143 = $[14], t13 = t143;
      break bb0;
    }
    let t142;
    $[15] !== comlink || $[16] !== componentResolver || $[17] !== dragMinimapTransition || $[18] !== dragShowMinimap || $[19] !== elements || $[20] !== inFrame || $[21] !== isDragging || $[22] !== optimisticActorReady || $[23] !== props.plugins || $[24] !== wasMaybeCollapsed ? (t142 = elements.filter(_temp9).map((t152) => {
      const {
        id,
        element: element_0,
        focused,
        hovered,
        rect,
        sanity,
        dragDisabled,
        targets,
        elementType
      } = t152, draggable = !dragDisabled && !!element_0.getAttribute("data-sanity") && optimisticActorReady && elements.some((e_2) => "id" in e_2.sanity && "id" in sanity ? sanityNodesExistInSameArray(e_2.sanity, sanity) && e_2.sanity.path !== sanity.path : !1);
      return /* @__PURE__ */ jsx(ElementOverlay, { comlink, componentResolver, plugins: props.plugins, element: element_0, enableScrollIntoView: !isDragging && !dragMinimapTransition && !dragShowMinimap, id, focused, hovered, node: sanity, rect, showActions: !inFrame, draggable, isDragging: isDragging || dragMinimapTransition, wasMaybeCollapsed: focused && wasMaybeCollapsed, targets, elementType }, id);
    }), $[15] = comlink, $[16] = componentResolver, $[17] = dragMinimapTransition, $[18] = dragShowMinimap, $[19] = elements, $[20] = inFrame, $[21] = isDragging, $[22] = optimisticActorReady, $[23] = props.plugins, $[24] = wasMaybeCollapsed, $[25] = t142) : t142 = $[25], t13 = t142;
  }
  const elementsToRender = t13, t14 = prefersDark ? "dark" : "light", t15 = fadingOut ? "" : void 0, t16 = overlaysFlash ? "" : void 0;
  let t17;
  $[26] !== documentIds || $[27] !== perspective ? (t17 = /* @__PURE__ */ jsx(DocumentReporter, { documentIds, perspective }), $[26] = documentIds, $[27] = perspective, $[28] = t17) : t17 = $[28];
  let t18;
  $[29] !== comlink || $[30] !== inFrame || $[31] !== inPopUp || $[32] !== overlayEnabled || $[33] !== rootElement || $[34] !== updateDragPreviewCustomProps ? (t18 = /* @__PURE__ */ jsx(OverlaysController, { comlink, dispatch, inFrame, inPopUp, onDrag: updateDragPreviewCustomProps, overlayEnabled, rootElement }), $[29] = comlink, $[30] = inFrame, $[31] = inPopUp, $[32] = overlayEnabled, $[33] = rootElement, $[34] = updateDragPreviewCustomProps, $[35] = t18) : t18 = $[35];
  let t19;
  $[36] !== contextMenu ? (t19 = contextMenu && /* @__PURE__ */ jsx(ContextMenu, { ...contextMenu, onDismiss: closeContextMenu }), $[36] = contextMenu, $[37] = t19) : t19 = $[37];
  let t20;
  $[38] !== dragGroupRect || $[39] !== dragInsertPosition || $[40] !== dragMinimapTransition || $[41] !== dragShowMinimapPrompt || $[42] !== isDragging ? (t20 = isDragging && !dragMinimapTransition && /* @__PURE__ */ jsxs(Fragment, { children: [
    dragInsertPosition && /* @__PURE__ */ jsx(OverlayDragInsertMarker, { dragInsertPosition }),
    dragShowMinimapPrompt && /* @__PURE__ */ jsx(OverlayMinimapPrompt, {}),
    dragGroupRect && /* @__PURE__ */ jsx(OverlayDragGroupRect, { dragGroupRect })
  ] }), $[38] = dragGroupRect, $[39] = dragInsertPosition, $[40] = dragMinimapTransition, $[41] = dragShowMinimapPrompt, $[42] = isDragging, $[43] = t20) : t20 = $[43];
  let t21;
  $[44] !== dragSkeleton || $[45] !== isDragging ? (t21 = isDragging && dragSkeleton && /* @__PURE__ */ jsx(OverlayDragPreview, { skeleton: dragSkeleton }), $[44] = dragSkeleton, $[45] = isDragging, $[46] = t21) : t21 = $[46];
  let t22;
  $[47] !== elementsToRender || $[48] !== t15 || $[49] !== t16 || $[50] !== t17 || $[51] !== t18 || $[52] !== t19 || $[53] !== t20 || $[54] !== t21 || $[55] !== zIndex ? (t22 = /* @__PURE__ */ jsxs(Root, { "data-fading-out": t15, "data-overlays": t16, ref: setRootElement, $zIndex: zIndex, children: [
    t17,
    t18,
    t19,
    elementsToRender,
    t20,
    t21
  ] }), $[47] = elementsToRender, $[48] = t15, $[49] = t16, $[50] = t17, $[51] = t18, $[52] = t19, $[53] = t20, $[54] = t21, $[55] = zIndex, $[56] = t22) : t22 = $[56];
  let t23;
  $[57] !== comlink || $[58] !== t22 ? (t23 = /* @__PURE__ */ jsx(SharedStateProvider, { comlink, children: t22 }), $[57] = comlink, $[58] = t22, $[59] = t23) : t23 = $[59];
  let t24;
  $[60] !== comlink || $[61] !== t23 ? (t24 = /* @__PURE__ */ jsx(PreviewSnapshotsProvider, { comlink, children: t23 }), $[60] = comlink, $[61] = t23, $[62] = t24) : t24 = $[62];
  let t25;
  $[63] !== comlink || $[64] !== elements || $[65] !== t24 ? (t25 = /* @__PURE__ */ jsx(SchemaProvider, { comlink, elements, children: t24 }), $[63] = comlink, $[64] = elements, $[65] = t24, $[66] = t25) : t25 = $[66];
  let t26;
  $[67] !== rootElement || $[68] !== t25 ? (t26 = /* @__PURE__ */ jsx(LayerProvider, { children: /* @__PURE__ */ jsx(PortalProvider, { element: rootElement, children: t25 }) }), $[67] = rootElement, $[68] = t25, $[69] = t26) : t26 = $[69];
  let t27;
  $[70] !== t14 || $[71] !== t26 ? (t27 = /* @__PURE__ */ jsx(ThemeProvider, { scheme: t14, theme: studioTheme, tone: "transparent", children: t26 }), $[70] = t14, $[71] = t26, $[72] = t27) : t27 = $[72];
  let t28;
  return $[73] !== comlink || $[74] !== t27 ? (t28 = /* @__PURE__ */ jsx(TelemetryProvider, { comlink, children: t27 }), $[73] = comlink, $[74] = t27, $[75] = t28) : t28 = $[75], t28;
}, IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {
  alt: "altKey",
  ctrl: "ctrlKey",
  mod: IS_MAC ? "metaKey" : "ctrlKey",
  shift: "shiftKey"
};
function isHotkey(keys, event) {
  return keys.every((key) => MODIFIERS[key] ? event[MODIFIERS[key]] : event.key === key.toUpperCase());
}
function isAltKey(event) {
  return event.key === "Alt";
}
function _temp$2(acc, prevId) {
  return acc.filter((id) => id !== prevId);
}
function _temp2$1(enabled) {
  return !enabled;
}
function _temp3(unsub) {
  return unsub();
}
function _temp4(event) {
  const target = event.target;
  if ((isHTMLAnchorElement(target) || isHTMLElement(target) && target.closest("a")) && event.altKey) {
    event.preventDefault(), event.stopPropagation();
    const newEvent = new MouseEvent(event.type, {
      ...event,
      altKey: !1,
      bubbles: !0,
      cancelable: !0
    });
    event.target?.dispatchEvent(newEvent);
  }
}
function _temp5(enabled_0) {
  return !enabled_0;
}
function _temp6(enabled_1) {
  return !enabled_1;
}
function _temp7(enabled_2) {
  return !enabled_2;
}
function _temp8(element) {
  return "id" in element.sanity ? [element.sanity.id] : [];
}
function _temp9(e_1) {
  return e_1.activated || e_1.focused;
}
const Refresh = (props) => {
  const $ = c(4), {
    comlink,
    refresh
  } = props, manualRefreshRef = useRef(0), mutationRefreshRef = useRef(0);
  let t0, t1;
  return $[0] !== comlink || $[1] !== refresh ? (t0 = () => comlink.on("presentation/refresh", (data) => {
    if (data.source === "manual") {
      clearTimeout(manualRefreshRef.current);
      const promise = refresh(data);
      if (promise === !1)
        return;
      comlink.post("visual-editing/refreshing", data);
      let timedOut = !1;
      manualRefreshRef.current = window.setTimeout(() => {
        comlink.post("visual-editing/refreshed", data), timedOut = !0;
      }, 3e3), promise?.finally?.(() => {
        timedOut || (clearTimeout(manualRefreshRef.current), comlink.post("visual-editing/refreshed", data));
      });
    } else if (data.source === "mutation") {
      clearTimeout(mutationRefreshRef.current);
      const promise_0 = refresh(data);
      if (promise_0 === !1)
        return;
      comlink.post("visual-editing/refreshing", data), mutationRefreshRef.current = window.setTimeout(() => {
        const promise_1 = refresh(data);
        promise_1 !== !1 && (comlink.post("visual-editing/refreshing", data), promise_1?.finally?.(() => {
          comlink.post("visual-editing/refreshed", data);
        }) || comlink.post("visual-editing/refreshed", data));
      }, 1e3), promise_0?.finally?.(() => {
        comlink.post("visual-editing/refreshed", data);
      }) || comlink.post("visual-editing/refreshed", data);
    }
  }), t1 = [comlink, refresh], $[0] = comlink, $[1] = refresh, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), useEffect(t0, t1), null;
};
function useComlink(t0) {
  const $ = c(9), active = t0 === void 0 ? !0 : t0, [node, setNode] = useState(), [status, setStatus] = useState("idle");
  let t1, t2;
  $[0] !== active ? (t1 = () => {
    if (!active)
      return;
    const instance = createNode({
      name: "visual-editing",
      connectTo: "presentation"
    }, createNodeMachine().provide({
      actors: createCompatibilityActors()
    })), unsub = instance.onStatus(() => setStatus("connected"), "connected");
    setNode(instance);
    const stop = instance.start();
    return () => {
      unsub(), stop(), setNode(void 0);
    };
  }, t2 = [active], $[0] = active, $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]), useEffect(t1, t2);
  let t3, t4;
  $[3] !== status ? (t3 = () => {
    if (status === "connected")
      return;
    const controller = new AbortController();
    return window.addEventListener("message", _temp$1, {
      signal: controller.signal
    }), () => {
      controller.abort();
    };
  }, t4 = [status], $[3] = status, $[4] = t3, $[5] = t4) : (t3 = $[4], t4 = $[5]), useEffect(t3, t4);
  let t5;
  return $[6] !== node || $[7] !== status ? (t5 = [node, status], $[6] = node, $[7] = status, $[8] = t5) : t5 = $[8], t5;
}
function _temp$1(t0) {
  const {
    data,
    origin
  } = t0;
  data && typeof data == "object" && "domain" in data && data.domain === "sanity/channels" && "from" in data && data.from === "presentation" && "type" in data && data.type === "presentation/status" && window.parent.postMessage({
    domain: "sanity/channels",
    type: "visual-editing/status",
    data: {
      origin: location.origin
    }
  }, origin);
}
function createSharedListener(comlink) {
  const incomingConnection$ = new ReplaySubject(1), incomingMutations$ = new Subject();
  return comlink.fetch("visual-editing/snapshot-welcome", void 0, {
    suppressWarnings: !0
  }).then((data) => {
    incomingConnection$.next(data.event);
  }).catch(() => {
  }), comlink.on("presentation/snapshot-event", (data) => {
    data.event.type === "reconnect" && incomingConnection$.next(data.event), data.event.type === "mutation" && incomingMutations$.next(data.event);
  }), merge(incomingConnection$, incomingMutations$);
}
function useDatasetMutator(comlink) {
  const $ = c(3);
  let t0, t1;
  $[0] !== comlink ? (t0 = () => {
    if (!comlink)
      return;
    const listener = createSharedListener(comlink), datasetMutator = createDatasetMutator(comlink), mutator = createActor(datasetMutator, {
      input: {
        client: {
          withConfig: _temp
        },
        sharedListener: listener
      }
    });
    mutator.start();
    const featuresFetch = new AbortController();
    return comlink.fetch("visual-editing/features", void 0, {
      signal: featuresFetch.signal,
      suppressWarnings: !0
    }).then((data) => {
      data.features.optimistic && setActor(mutator);
    }).catch(_temp2), () => {
      mutator.stop(), featuresFetch.abort();
    };
  }, t1 = [comlink], $[0] = comlink, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
}
function _temp2() {
  console.warn("[@sanity/visual-editing] Package version mismatch detected: Please update your Sanity studio to prevent potential compatibility issues.");
}
function _temp() {
}
const VisualEditing = (props) => {
  const $ = c(23), {
    components,
    plugins,
    history,
    portal: t0,
    refresh,
    zIndex
  } = props, portal = t0 === void 0 ? !0 : t0, [inFrame, setInFrame] = useState(null), [inPopUp, setInPopUp] = useState(null);
  let t1, t2;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => {
    setInFrame(isMaybePreviewIframe()), setInPopUp(isMaybePreviewWindow());
  }, t2 = [], $[0] = t1, $[1] = t2) : (t1 = $[0], t2 = $[1]), useEffect(t1, t2);
  const [portalElement, setPortalElement] = useState(null);
  let t3, t4;
  $[2] !== portal ? (t3 = () => {
    if (portal === !1)
      return;
    const node = document.createElement("sanity-visual-editing");
    return document.documentElement.appendChild(node), setPortalElement(node), () => {
      setPortalElement(null), document.documentElement.contains(node) && document.documentElement.removeChild(node);
    };
  }, t4 = [portal], $[2] = portal, $[3] = t3, $[4] = t4) : (t3 = $[3], t4 = $[4]), useEffect(t3, t4);
  const [comlink, comlinkStatus] = useComlink(inFrame === !0 || inPopUp === !0);
  useDatasetMutator(comlinkStatus === "connected" ? comlink : void 0);
  let t5;
  $[5] !== comlink || $[6] !== comlinkStatus || $[7] !== components || $[8] !== inFrame || $[9] !== inPopUp || $[10] !== plugins || $[11] !== zIndex ? (t5 = inFrame !== null && inPopUp !== null && /* @__PURE__ */ jsx(Overlays, { comlink, comlinkStatus, componentResolver: components, plugins, inFrame, inPopUp, zIndex }), $[5] = comlink, $[6] = comlinkStatus, $[7] = components, $[8] = inFrame, $[9] = inPopUp, $[10] = plugins, $[11] = zIndex, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== comlink || $[14] !== history || $[15] !== refresh ? (t6 = comlink && /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(History, { comlink, history }),
    /* @__PURE__ */ jsx(Meta, { comlink }),
    refresh && /* @__PURE__ */ jsx(Refresh, { comlink, refresh })
  ] }), $[13] = comlink, $[14] = history, $[15] = refresh, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== t5 || $[18] !== t6 ? (t7 = /* @__PURE__ */ jsxs(Fragment, { children: [
    t5,
    t6
  ] }), $[17] = t5, $[18] = t6, $[19] = t7) : t7 = $[19];
  const children = t7;
  if (portal === !1 || !portalElement)
    return children;
  let t8;
  return $[20] !== children || $[21] !== portalElement ? (t8 = createPortal(children, portalElement), $[20] = children, $[21] = portalElement, $[22] = t8) : t8 = $[22], t8;
};
VisualEditing.displayName = "VisualEditing";
export {
  VisualEditing,
  createDataAttribute,
  createDatasetMutator,
  createDocumentMutator,
  emptyActor,
  useDocuments,
  useOptimistic,
  useOptimisticActor
};
//# sourceMappingURL=index.js.map
