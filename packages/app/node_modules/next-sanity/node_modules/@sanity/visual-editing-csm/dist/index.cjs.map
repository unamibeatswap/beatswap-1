{"version":3,"file":"index.cjs","sources":["../src/sanityNodeSchema.ts","../src/isValidSanityNode.ts","../src/isArray.ts","../src/pathToUrlString.ts","../src/encodeSanityNodeData.ts","../src/createDataAttribute.ts","../src/urlStringToPath.ts","../src/decodeSanityNodeData.ts"],"sourcesContent":["import {minLength, object, optional, pipe, string} from 'valibot'\n\nconst lengthyStr = pipe(string(), minLength(1))\nconst optionalLengthyStr = optional(lengthyStr)\n\nexport const sanityNodeSchema = object({\n  baseUrl: lengthyStr,\n  dataset: optionalLengthyStr,\n  id: lengthyStr,\n  path: lengthyStr,\n  projectId: optionalLengthyStr,\n  tool: optionalLengthyStr,\n  type: optionalLengthyStr,\n  workspace: optionalLengthyStr,\n})\n","import type {SanityNode} from '@sanity/visual-editing-types'\nimport {is} from 'valibot'\nimport {sanityNodeSchema} from './sanityNodeSchema'\n\n/** @internal */\nexport function isValidSanityNode(node: Partial<SanityNode>): node is SanityNode {\n  return is(sanityNodeSchema, node)\n}\n","export function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","import type {Path} from '@sanity/client/csm'\nimport {isArray} from './isArray'\n\n/** @internal */\nexport function pathToUrlString(path: Path): string {\n  let str = ''\n\n  for (const segment of path) {\n    if (typeof segment === 'string') {\n      if (str) str += '.'\n      str += segment\n      continue\n    }\n\n    if (typeof segment === 'number') {\n      if (str) str += ':'\n      str += `${segment}`\n      continue\n    }\n\n    if (isArray(segment)) {\n      if (str) str += ':'\n      str += `${segment.join(',')}}`\n      continue\n    }\n\n    if (segment._key) {\n      if (str) str += ':'\n      str += `${segment._key}`\n      continue\n    }\n  }\n\n  return str\n}\n","import {getPublishedId, studioPath} from '@sanity/client/csm'\nimport type {SanityNode} from '@sanity/visual-editing-types'\nimport {isValidSanityNode} from './isValidSanityNode'\nimport {pathToUrlString} from './pathToUrlString'\n\n/**\n * Transforms sanity node data into an encoded string\n * @param node - An unencoded sanity node object\n * @returns An encoded string of sanity data\n * @public\n */\nexport function encodeSanityNodeData(node: SanityNode): string | undefined {\n  const {id: _id, path, baseUrl, tool, workspace, type} = node\n\n  if (!isValidSanityNode(node)) {\n    return undefined\n  }\n\n  const parts = [\n    ['id', getPublishedId(_id)],\n    ['type', type],\n    ['path', pathToUrlString(studioPath.fromString(path))],\n    ['base', encodeURIComponent(baseUrl)],\n    ['workspace', workspace],\n    ['tool', tool],\n  ]\n\n  return parts\n    .filter(([, value]) => !!value)\n    .map((part) => part.join('='))\n    .join(';')\n}\n","import {studioPath, type StudioPathLike} from '@sanity/client/csm'\nimport type {SanityNode} from '@sanity/visual-editing-types'\nimport {encodeSanityNodeData} from './encodeSanityNodeData'\n\n/**\n * Helper\n * @internal\n */\nexport type WithRequired<T, K extends keyof T> = T & {[P in K]-?: T[P]}\n\n/**\n * The metadata that can be embedded in a data attribute.\n * All values are marked optional in the base type as they can be provided incrementally using the `createDataAttribute` function.\n * @public\n */\nexport interface CreateDataAttributeProps {\n  /** The studio base URL, optional */\n  baseUrl?: string\n  /** The dataset, optional */\n  dataset?: string\n  /** The document ID, required */\n  id?: string\n  /** The field path, required */\n  path?: StudioPathLike\n  /** The project ID, optional */\n  projectId?: string\n  /** The studio tool name, optional */\n  tool?: string\n  /** The document type, required */\n  type?: string\n  /** The studio workspace, optional */\n  workspace?: string\n}\n\n/**\n * @public\n */\nexport type CreateDataAttribute<T extends CreateDataAttributeProps> = (T extends WithRequired<\n  CreateDataAttributeProps,\n  'id' | 'type' | 'path'\n>\n  ? {\n      /**\n       * Returns a string representation of the data attribute\n       * @param path - An optional path to concatenate with any existing path\n       * @public\n       */\n      (path?: StudioPathLike): string\n      /**\n       * Returns a string representation of the data attribute\n       * @public\n       */\n      toString(): string\n    }\n  : T extends WithRequired<CreateDataAttributeProps, 'id' | 'type'>\n    ? /**\n       * Returns a string representation of the data attribute\n       * @param path - An optional path to concatenate with any existing path\n       * @public\n       */\n      (path: StudioPathLike) => string\n    : object) & {\n  /**\n   * Concatenate the current path with a new path\n   * @param path - A path to concatenate with any existing path\n   * @public\n   */\n  scope(path: StudioPathLike): CreateDataAttribute<T & {path: StudioPathLike}>\n  /**\n   * Combines the current props with additional props\n   * @param props - New props to merge with any existing props\n   * @public\n   */\n  combine: <U extends CreateDataAttributeProps>(props: U) => CreateDataAttribute<T & U>\n}\n\n/**\n * A helper function for creating `data-sanity` attributes by explicitly providing metadata.\n * @returns An object with methods for incrementally adding and scoping metadata, and for generating a data attribute string.\n * @public\n */\nexport function createDataAttribute<T extends CreateDataAttributeProps>(\n  props: T,\n): CreateDataAttribute<T> {\n  // Internal function for normalizing a path\n  function normalizePath(path?: StudioPathLike) {\n    if (!path) return []\n    return typeof path === 'string' ? studioPath.fromString(path) : path\n  }\n\n  // Internal function for building a data attribute string\n  function toString(props: CreateDataAttributeProps): string {\n    if (!props.id) throw new Error('`id` is required to create a data attribute')\n    if (!props.type) throw new Error('`type` is required to create a data attribute')\n    if (!props.path || !props.path.length)\n      throw new Error('`path` is required to create a data attribute')\n\n    const attrs = {\n      baseUrl: props.baseUrl || '/',\n      workspace: props.workspace,\n      tool: props.tool,\n      type: props.type,\n      id: props.id,\n      path: typeof props.path === 'string' ? props.path : studioPath.toString(props.path),\n    } satisfies SanityNode\n\n    return encodeSanityNodeData(attrs)!\n  }\n\n  // The returned function call, calls the internal `toString` function with an optional concatenated path\n  const DataAttribute = (path?: StudioPathLike): string => {\n    return toString({\n      ...props,\n      path: [...normalizePath(props.path), ...normalizePath(path)],\n    })\n  }\n\n  // Alternative to the function call, but does not accept a path to concatenate\n  DataAttribute.toString = function () {\n    return toString(props)\n  }\n\n  DataAttribute.combine = function <U extends CreateDataAttributeProps>(attrs: U) {\n    return createDataAttribute<T & U>({\n      ...props,\n      ...attrs,\n    })\n  }\n\n  DataAttribute.scope = function (path: StudioPathLike) {\n    return createDataAttribute<T & {path: StudioPathLike}>({\n      ...props,\n      path: [...normalizePath(props.path), ...normalizePath(path)],\n    })\n  }\n\n  return DataAttribute as CreateDataAttribute<T>\n}\n","import type {Path} from '@sanity/client/csm'\n\nconst RE_SEGMENT_WITH_INDEX = /^([\\w-]+):(0|[1-9][0-9]*)$/\nconst RE_SEGMENT_WITH_TUPLE = /^([\\w-]+):([0-9]+),([0-9]+)$/\nconst RE_SEGMENT_WITH_KEY = /^([\\w-]+):([\\w-]+)$/\n\n/** @internal */\nexport function urlStringToPath(str: string): Path {\n  const path: Path = []\n\n  for (const segment of str.split('.')) {\n    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment)\n\n    if (withIndex) {\n      path.push(withIndex[1], Number(withIndex[2]))\n      continue\n    }\n\n    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment)\n\n    if (withTuple) {\n      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])])\n      continue\n    }\n\n    const withKey = RE_SEGMENT_WITH_KEY.exec(segment)\n\n    if (withKey) {\n      path.push(withKey[1], {_key: withKey[2]})\n      continue\n    }\n\n    path.push(segment)\n  }\n\n  return path\n}\n","import {studioPath} from '@sanity/client/csm'\nimport type {SanityNode, SanityStegaNode} from '@sanity/visual-editing-types'\nimport {minLength, object, optional, parse, pipe, record, safeParse, string, unknown} from 'valibot'\nimport {isValidSanityNode} from './isValidSanityNode'\nimport {sanityNodeSchema} from './sanityNodeSchema'\nimport {urlStringToPath} from './urlStringToPath'\n\nconst lengthyStr = pipe(string(), minLength(1))\n\nconst sanityLegacyNodeSchema = object({\n  origin: lengthyStr,\n  href: lengthyStr,\n  data: optional(record(string(), unknown())),\n})\n\n/**\n * Transforms a sanity data string into sanity node data\n * @param str - An encoded string of sanity data\n * @internal\n */\nexport function decodeSanityString(str: string): SanityNode | undefined {\n  const segments = str.split(';')\n\n  const data = segments.reduce((acc, segment) => {\n    const [key, value] = segment.split('=')\n    if (!key || (segment.includes('=') && !value)) return acc\n\n    switch (key) {\n      case 'id':\n        acc.id = value\n        break\n      case 'type':\n        acc.type = value\n        break\n      case 'path':\n        acc.path = studioPath.toString(urlStringToPath(value))\n        break\n      case 'base':\n        acc.baseUrl = decodeURIComponent(value)\n        break\n      case 'tool':\n        acc.tool = value\n        break\n      case 'workspace':\n        acc.workspace = value\n        break\n      case 'projectId':\n        acc.projectId = value\n        break\n      case 'dataset':\n        acc.dataset = value\n        break\n      default:\n    }\n\n    return acc\n  }, {} as Partial<SanityNode>)\n\n  if (!isValidSanityNode(data)) return undefined\n\n  return data\n}\n\n/**\n * Transforms stringified JSON into sanity node data\n * @param str - JSON sanity data\n */\nfunction decodeSanityObject(\n  data: Record<string, unknown>,\n): SanityNode | SanityStegaNode | undefined {\n  const sanityNode = safeParse(sanityNodeSchema, data)\n  if (sanityNode.success) {\n    return sanityNode.output\n  }\n  const sanityLegacyNode = safeParse(sanityLegacyNodeSchema, data)\n  if (sanityLegacyNode.success) {\n    try {\n      const url = new URL(\n        sanityLegacyNode.output.href,\n        typeof document === 'undefined' ? 'https://example.com' : location.origin,\n      )\n      if (url.searchParams.size > 0) {\n        return parse(sanityNodeSchema, Object.fromEntries(url.searchParams.entries()))\n      }\n      return sanityLegacyNode.output\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Failed to parse sanity node', err)\n      return sanityLegacyNode.output\n    }\n  }\n  return undefined\n}\n\n/**\n * Transforms sanity data from multiple formats into sanity node data\n * @param str - Sanity data as a string of unknown format\n * @internal\n */\nexport function decodeSanityNodeData(\n  data: SanityStegaNode | string,\n): SanityNode | SanityStegaNode | undefined {\n  if (typeof data === 'object' && data !== null) {\n    return decodeSanityObject(data)\n  }\n  try {\n    const obj = JSON.parse(data)\n    return decodeSanityObject(obj)\n  } catch {\n    return decodeSanityString(data)\n  }\n}\n"],"names":["lengthyStr","pipe","string","minLength","optional","object","is","getPublishedId","studioPath","props","record","unknown","safeParse","parse"],"mappings":";;;AAEA,MAAMA,eAAaC,QAAAA,KAAKC,QAAA,OAAA,GAAUC,QAAA,UAAU,CAAC,CAAC,GACxC,qBAAqBC,QAAA,SAASJ,YAAU,GAEjC,mBAAmBK,QAAAA,OAAO;AAAA,EACrC,SAASL;AAAAA,EACT,SAAS;AAAA,EACT,IAAIA;AAAAA,EACJ,MAAMA;AAAAA,EACN,WAAW;AAAA,EACX,MAAM;AAAA,EACN,MAAM;AAAA,EACN,WAAW;AACb,CAAC;ACTM,SAAS,kBAAkB,MAA+C;AACxE,SAAAM,QAAA,GAAG,kBAAkB,IAAI;AAClC;ACPO,SAAS,QAAQ,OAAyC;AAC/D,SAAO,UAAU,QAAQ,MAAM,QAAQ,KAAK;AAC9C;ACEO,SAAS,gBAAgB,MAAoB;AAClD,MAAI,MAAM;AAEV,aAAW,WAAW,MAAM;AACtB,QAAA,OAAO,WAAY,UAAU;AAC3B,cAAK,OAAO,MAChB,OAAO;AACP;AAAA,IAAA;AAGE,QAAA,OAAO,WAAY,UAAU;AAC3B,cAAK,OAAO,MAChB,OAAO,GAAG,OAAO;AACjB;AAAA,IAAA;AAGE,QAAA,QAAQ,OAAO,GAAG;AAChB,cAAK,OAAO,MAChB,OAAO,GAAG,QAAQ,KAAK,GAAG,CAAC;AAC3B;AAAA,IAAA;AAGF,QAAI,QAAQ,MAAM;AACZ,cAAK,OAAO,MAChB,OAAO,GAAG,QAAQ,IAAI;AACtB;AAAA,IAAA;AAAA,EACF;AAGK,SAAA;AACT;ACvBO,SAAS,qBAAqB,MAAsC;AACnE,QAAA,EAAC,IAAI,KAAK,MAAM,SAAS,MAAM,WAAW,SAAQ;AAEnD,SAAA,kBAAkB,IAAI,IAIb;AAAA,IACZ,CAAC,MAAMC,mBAAe,GAAG,CAAC;AAAA,IAC1B,CAAC,QAAQ,IAAI;AAAA,IACb,CAAC,QAAQ,gBAAgBC,IAAAA,WAAW,WAAW,IAAI,CAAC,CAAC;AAAA,IACrD,CAAC,QAAQ,mBAAmB,OAAO,CAAC;AAAA,IACpC,CAAC,aAAa,SAAS;AAAA,IACvB,CAAC,QAAQ,IAAI;AAAA,EAAA,EAIZ,OAAO,CAAC,CAAG,EAAA,KAAK,MAAM,CAAC,CAAC,KAAK,EAC7B,IAAI,CAAC,SAAS,KAAK,KAAK,GAAG,CAAC,EAC5B,KAAK,GAAG,IAfT;AAgBJ;ACkDO,SAAS,oBACd,OACwB;AAExB,WAAS,cAAc,MAAuB;AACvC,WAAA,OACE,OAAO,QAAS,WAAWA,eAAW,WAAW,IAAI,IAAI,OAD9C,CAAC;AAAA,EAAA;AAKrB,WAAS,SAASC,QAAyC;AACzD,QAAI,CAACA,OAAM,GAAU,OAAA,IAAI,MAAM,6CAA6C;AAC5E,QAAI,CAACA,OAAM,KAAY,OAAA,IAAI,MAAM,+CAA+C;AAChF,QAAI,CAACA,OAAM,QAAQ,CAACA,OAAM,KAAK;AACvB,YAAA,IAAI,MAAM,+CAA+C;AAEjE,UAAM,QAAQ;AAAA,MACZ,SAASA,OAAM,WAAW;AAAA,MAC1B,WAAWA,OAAM;AAAA,MACjB,MAAMA,OAAM;AAAA,MACZ,MAAMA,OAAM;AAAA,MACZ,IAAIA,OAAM;AAAA,MACV,MAAM,OAAOA,OAAM,QAAS,WAAWA,OAAM,OAAOD,IAAA,WAAW,SAASC,OAAM,IAAI;AAAA,IACpF;AAEA,WAAO,qBAAqB,KAAK;AAAA,EAAA;AAI7B,QAAA,gBAAgB,CAAC,SACd,SAAS;AAAA,IACd,GAAG;AAAA,IACH,MAAM,CAAC,GAAG,cAAc,MAAM,IAAI,GAAG,GAAG,cAAc,IAAI,CAAC;AAAA,EAAA,CAC5D;AAIH,SAAA,cAAc,WAAW,WAAY;AACnC,WAAO,SAAS,KAAK;AAAA,EAAA,GAGvB,cAAc,UAAU,SAA8C,OAAU;AAC9E,WAAO,oBAA2B;AAAA,MAChC,GAAG;AAAA,MACH,GAAG;AAAA,IAAA,CACJ;AAAA,EAAA,GAGH,cAAc,QAAQ,SAAU,MAAsB;AACpD,WAAO,oBAAgD;AAAA,MACrD,GAAG;AAAA,MACH,MAAM,CAAC,GAAG,cAAc,MAAM,IAAI,GAAG,GAAG,cAAc,IAAI,CAAC;AAAA,IAAA,CAC5D;AAAA,EAAA,GAGI;AACT;ACvIA,MAAM,wBAAwB,8BACxB,wBAAwB,gCACxB,sBAAsB;AAGrB,SAAS,gBAAgB,KAAmB;AACjD,QAAM,OAAa,CAAC;AAEpB,aAAW,WAAW,IAAI,MAAM,GAAG,GAAG;AAC9B,UAAA,YAAY,sBAAsB,KAAK,OAAO;AAEpD,QAAI,WAAW;AACR,WAAA,KAAK,UAAU,CAAC,GAAG,OAAO,UAAU,CAAC,CAAC,CAAC;AAC5C;AAAA,IAAA;AAGI,UAAA,YAAY,sBAAsB,KAAK,OAAO;AAEpD,QAAI,WAAW;AACb,WAAK,KAAK,UAAU,CAAC,GAAG,CAAC,OAAO,UAAU,CAAC,CAAC,GAAG,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;AACpE;AAAA,IAAA;AAGI,UAAA,UAAU,oBAAoB,KAAK,OAAO;AAEhD,QAAI,SAAS;AACN,WAAA,KAAK,QAAQ,CAAC,GAAG,EAAC,MAAM,QAAQ,CAAC,GAAE;AACxC;AAAA,IAAA;AAGF,SAAK,KAAK,OAAO;AAAA,EAAA;AAGZ,SAAA;AACT;AC7BA,MAAM,aAAaR,QAAAA,KAAKC,QAAAA,UAAUC,QAAAA,UAAU,CAAC,CAAC,GAExC,yBAAyBE,eAAO;AAAA,EACpC,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAMD,QAAAA,SAASM,QAAAA,OAAOR,QAAAA,OAAU,GAAAS,QAAA,QAAA,CAAS,CAAC;AAC5C,CAAC;AAOM,SAAS,mBAAmB,KAAqC;AAGhE,QAAA,OAFW,IAAI,MAAM,GAAG,EAER,OAAO,CAAC,KAAK,YAAY;AAC7C,UAAM,CAAC,KAAK,KAAK,IAAI,QAAQ,MAAM,GAAG;AAClC,QAAA,CAAC,OAAQ,QAAQ,SAAS,GAAG,KAAK,CAAC,MAAe,QAAA;AAEtD,YAAQ,KAAK;AAAA,MACX,KAAK;AACH,YAAI,KAAK;AACT;AAAA,MACF,KAAK;AACH,YAAI,OAAO;AACX;AAAA,MACF,KAAK;AACH,YAAI,OAAOH,IAAA,WAAW,SAAS,gBAAgB,KAAK,CAAC;AACrD;AAAA,MACF,KAAK;AACC,YAAA,UAAU,mBAAmB,KAAK;AACtC;AAAA,MACF,KAAK;AACH,YAAI,OAAO;AACX;AAAA,MACF,KAAK;AACH,YAAI,YAAY;AAChB;AAAA,MACF,KAAK;AACH,YAAI,YAAY;AAChB;AAAA,MACF,KAAK;AACH,YAAI,UAAU;AACd;AAAA,IACF;AAGK,WAAA;AAAA,EACT,GAAG,EAAyB;AAE5B,MAAK,kBAAkB,IAAI;AAEpB,WAAA;AACT;AAMA,SAAS,mBACP,MAC0C;AACpC,QAAA,aAAaI,QAAAA,UAAU,kBAAkB,IAAI;AACnD,MAAI,WAAW;AACb,WAAO,WAAW;AAEd,QAAA,mBAAmBA,QAAAA,UAAU,wBAAwB,IAAI;AAC/D,MAAI,iBAAiB;AACf,QAAA;AACF,YAAM,MAAM,IAAI;AAAA,QACd,iBAAiB,OAAO;AAAA,QACxB,OAAO,WAAa,MAAc,wBAAwB,SAAS;AAAA,MACrE;AACA,aAAI,IAAI,aAAa,OAAO,IACnBC,QAAAA,MAAM,kBAAkB,OAAO,YAAY,IAAI,aAAa,QAAS,CAAA,CAAC,IAExE,iBAAiB;AAAA,aACjB,KAAK;AAEZ,aAAA,QAAQ,MAAM,+BAA+B,GAAG,GACzC,iBAAiB;AAAA,IAAA;AAI9B;AAOO,SAAS,qBACd,MAC0C;AACtC,MAAA,OAAO,QAAS,YAAY,SAAS;AACvC,WAAO,mBAAmB,IAAI;AAE5B,MAAA;AACI,UAAA,MAAM,KAAK,MAAM,IAAI;AAC3B,WAAO,mBAAmB,GAAG;AAAA,EAAA,QACvB;AACN,WAAO,mBAAmB,IAAI;AAAA,EAAA;AAElC;;;;;;"}