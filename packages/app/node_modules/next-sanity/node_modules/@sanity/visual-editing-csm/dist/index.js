import { getPublishedId, studioPath } from "@sanity/client/csm";
import { pipe, string, minLength, optional, object, is, record, unknown, safeParse, parse } from "valibot";
const lengthyStr$1 = pipe(string(), minLength(1)), optionalLengthyStr = optional(lengthyStr$1), sanityNodeSchema = object({
  baseUrl: lengthyStr$1,
  dataset: optionalLengthyStr,
  id: lengthyStr$1,
  path: lengthyStr$1,
  projectId: optionalLengthyStr,
  tool: optionalLengthyStr,
  type: optionalLengthyStr,
  workspace: optionalLengthyStr
});
function isValidSanityNode(node) {
  return is(sanityNodeSchema, node);
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function pathToUrlString(path) {
  let str = "";
  for (const segment of path) {
    if (typeof segment == "string") {
      str && (str += "."), str += segment;
      continue;
    }
    if (typeof segment == "number") {
      str && (str += ":"), str += `${segment}`;
      continue;
    }
    if (isArray(segment)) {
      str && (str += ":"), str += `${segment.join(",")}}`;
      continue;
    }
    if (segment._key) {
      str && (str += ":"), str += `${segment._key}`;
      continue;
    }
  }
  return str;
}
function encodeSanityNodeData(node) {
  const { id: _id, path, baseUrl, tool, workspace, type } = node;
  return isValidSanityNode(node) ? [
    ["id", getPublishedId(_id)],
    ["type", type],
    ["path", pathToUrlString(studioPath.fromString(path))],
    ["base", encodeURIComponent(baseUrl)],
    ["workspace", workspace],
    ["tool", tool]
  ].filter(([, value]) => !!value).map((part) => part.join("=")).join(";") : void 0;
}
function createDataAttribute(props) {
  function normalizePath(path) {
    return path ? typeof path == "string" ? studioPath.fromString(path) : path : [];
  }
  function toString(props2) {
    if (!props2.id) throw new Error("`id` is required to create a data attribute");
    if (!props2.type) throw new Error("`type` is required to create a data attribute");
    if (!props2.path || !props2.path.length)
      throw new Error("`path` is required to create a data attribute");
    const attrs = {
      baseUrl: props2.baseUrl || "/",
      workspace: props2.workspace,
      tool: props2.tool,
      type: props2.type,
      id: props2.id,
      path: typeof props2.path == "string" ? props2.path : studioPath.toString(props2.path)
    };
    return encodeSanityNodeData(attrs);
  }
  const DataAttribute = (path) => toString({
    ...props,
    path: [...normalizePath(props.path), ...normalizePath(path)]
  });
  return DataAttribute.toString = function() {
    return toString(props);
  }, DataAttribute.combine = function(attrs) {
    return createDataAttribute({
      ...props,
      ...attrs
    });
  }, DataAttribute.scope = function(path) {
    return createDataAttribute({
      ...props,
      path: [...normalizePath(props.path), ...normalizePath(path)]
    });
  }, DataAttribute;
}
const RE_SEGMENT_WITH_INDEX = /^([\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\w-]+):([\w-]+)$/;
function urlStringToPath(str) {
  const path = [];
  for (const segment of str.split(".")) {
    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
    if (withIndex) {
      path.push(withIndex[1], Number(withIndex[2]));
      continue;
    }
    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
    if (withTuple) {
      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);
      continue;
    }
    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
    if (withKey) {
      path.push(withKey[1], { _key: withKey[2] });
      continue;
    }
    path.push(segment);
  }
  return path;
}
const lengthyStr = pipe(string(), minLength(1)), sanityLegacyNodeSchema = object({
  origin: lengthyStr,
  href: lengthyStr,
  data: optional(record(string(), unknown()))
});
function decodeSanityString(str) {
  const data = str.split(";").reduce((acc, segment) => {
    const [key, value] = segment.split("=");
    if (!key || segment.includes("=") && !value) return acc;
    switch (key) {
      case "id":
        acc.id = value;
        break;
      case "type":
        acc.type = value;
        break;
      case "path":
        acc.path = studioPath.toString(urlStringToPath(value));
        break;
      case "base":
        acc.baseUrl = decodeURIComponent(value);
        break;
      case "tool":
        acc.tool = value;
        break;
      case "workspace":
        acc.workspace = value;
        break;
      case "projectId":
        acc.projectId = value;
        break;
      case "dataset":
        acc.dataset = value;
        break;
    }
    return acc;
  }, {});
  if (isValidSanityNode(data))
    return data;
}
function decodeSanityObject(data) {
  const sanityNode = safeParse(sanityNodeSchema, data);
  if (sanityNode.success)
    return sanityNode.output;
  const sanityLegacyNode = safeParse(sanityLegacyNodeSchema, data);
  if (sanityLegacyNode.success)
    try {
      const url = new URL(
        sanityLegacyNode.output.href,
        typeof document > "u" ? "https://example.com" : location.origin
      );
      return url.searchParams.size > 0 ? parse(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;
    } catch (err) {
      return console.error("Failed to parse sanity node", err), sanityLegacyNode.output;
    }
}
function decodeSanityNodeData(data) {
  if (typeof data == "object" && data !== null)
    return decodeSanityObject(data);
  try {
    const obj = JSON.parse(data);
    return decodeSanityObject(obj);
  } catch {
    return decodeSanityString(data);
  }
}
export {
  createDataAttribute,
  decodeSanityNodeData,
  encodeSanityNodeData,
  pathToUrlString,
  urlStringToPath
};
//# sourceMappingURL=index.js.map
