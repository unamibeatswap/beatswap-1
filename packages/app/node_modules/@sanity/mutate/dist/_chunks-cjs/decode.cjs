"use strict";
var parse = require("./parse.cjs");
function isCreateIfNotExistsMutation(sanityMutation) {
  return "createIfNotExists" in sanityMutation;
}
function isCreateOrReplaceMutation(sanityMutation) {
  return "createOrReplace" in sanityMutation;
}
function isCreateMutation(sanityMutation) {
  return "create" in sanityMutation;
}
function isDeleteMutation(sanityMutation) {
  return "delete" in sanityMutation;
}
function isPatchMutation(sanityMutation) {
  return "patch" in sanityMutation;
}
function isSetPatch(sanityPatch) {
  return "set" in sanityPatch;
}
function isSetIfMissingPatch(sanityPatch) {
  return "setIfMissing" in sanityPatch;
}
function isUnsetPatch(sanityPatch) {
  return "unset" in sanityPatch;
}
function isIncPatch(sanityPatch) {
  return "inc" in sanityPatch;
}
function isDecPatch(sanityPatch) {
  return "inc" in sanityPatch;
}
function isInsertPatch(sanityPatch) {
  return "insert" in sanityPatch;
}
function decodeAll(sanityMutations) {
  return sanityMutations.map(decodeMutation);
}
function decode(encodedMutation) {
  return decodeMutation(encodedMutation);
}
function decodeMutation(encodedMutation) {
  if (isCreateIfNotExistsMutation(encodedMutation))
    return {
      type: "createIfNotExists",
      document: encodedMutation.createIfNotExists
    };
  if (isCreateOrReplaceMutation(encodedMutation))
    return {
      type: "createOrReplace",
      document: encodedMutation.createOrReplace
    };
  if (isCreateMutation(encodedMutation))
    return { type: "create", document: encodedMutation.create };
  if (isDeleteMutation(encodedMutation))
    return { id: encodedMutation.delete.id, type: "delete" };
  if (isPatchMutation(encodedMutation))
    return {
      type: "patch",
      id: encodedMutation.patch.id,
      patches: decodeNodePatches(encodedMutation.patch)
    };
  throw new Error(`Unknown mutation: ${JSON.stringify(encodedMutation)}`);
}
const POSITION_KEYS = ["before", "replace", "after"];
function getInsertPosition(insert) {
  const positions = POSITION_KEYS.filter((k) => k in insert);
  if (positions.length > 1)
    throw new Error(
      `Insert patch is ambiguous. Should only contain one of: ${POSITION_KEYS.join(
        ", "
      )}, instead found ${positions.join(", ")}`
    );
  return positions[0];
}
function decodeNodePatches(patch) {
  return [
    ...getSetPatches(patch),
    ...getSetIfMissingPatches(patch),
    ...getUnsetPatches(patch),
    ...getIncPatches(patch),
    ...getDecPatches(patch),
    ...getInsertPatches(patch)
  ];
}
function getSetPatches(patch) {
  return isSetPatch(patch) ? Object.keys(patch.set).map((path) => ({
    path: parse.parse(path),
    op: { type: "set", value: patch.set[path] }
  })) : [];
}
function getSetIfMissingPatches(patch) {
  return isSetIfMissingPatch(patch) ? Object.keys(patch.setIfMissing).map((path) => ({
    path: parse.parse(path),
    op: { type: "setIfMissing", value: patch.setIfMissing[path] }
  })) : [];
}
function getUnsetPatches(patch) {
  return isUnsetPatch(patch) ? patch.unset.map((path) => ({
    path: parse.parse(path),
    op: { type: "unset" }
  })) : [];
}
function getIncPatches(patch) {
  return isIncPatch(patch) ? Object.keys(patch.inc).map((path) => ({
    path: parse.parse(path),
    op: { type: "inc", amount: patch.inc[path] }
  })) : [];
}
function getDecPatches(patch) {
  return isDecPatch(patch) ? Object.keys(patch.dec).map((path) => ({
    path: parse.parse(path),
    op: { type: "dec", amount: patch.dec[path] }
  })) : [];
}
function getInsertPatches(patch) {
  if (!isInsertPatch(patch))
    return [];
  const position = getInsertPosition(patch.insert);
  if (!position)
    throw new Error("Insert patch missing position");
  const path = parse.parse(patch.insert[position]), referenceItem = path.pop(), op = position === "replace" ? {
    type: "insert",
    position,
    referenceItem,
    items: patch.insert.items
  } : {
    type: "insert",
    position,
    referenceItem,
    items: patch.insert.items
  };
  return [{ path, op }];
}
exports.decode = decode;
exports.decodeAll = decodeAll;
//# sourceMappingURL=decode.cjs.map
