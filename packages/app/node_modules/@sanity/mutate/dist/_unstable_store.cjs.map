{"version":3,"file":"_unstable_store.cjs","sources":["../src/store/datasets/applyMendoza.ts","../src/store/datasets/createDataset.ts","../src/store/utils/createReplayMemoizer.ts","../src/store/utils/filterMutationGroups.ts","../src/store/contentLakeStore.ts"],"sourcesContent":["import {applyPatch, type RawPatch} from 'mendoza'\n\nimport {type SanityDocumentBase} from '../../mutations/types'\n\nfunction omitRev(document: SanityDocumentBase | undefined) {\n  if (document === undefined) {\n    return undefined\n  }\n  const {_rev, ...doc} = document\n  return doc\n}\n\nexport function applyMendozaPatch(\n  document: SanityDocumentBase | undefined,\n  patch: RawPatch,\n  patchBaseRev: string,\n): SanityDocumentBase | undefined {\n  if (patchBaseRev !== document?._rev) {\n    throw new Error(\n      'Invalid document revision. The provided patch is calculated from a different revision than the current document',\n    )\n  }\n  const next = applyPatch(omitRev(document), patch)\n  return next === null ? undefined : next\n}\n\nexport function applyMutationEventEffects(\n  document: SanityDocumentBase | undefined,\n  event: {effects: {apply: RawPatch}; previousRev: string; resultRev: string},\n) {\n  if (!event.effects) {\n    throw new Error(\n      'Mutation event is missing effects. Is the listener set up with effectFormat=mendoza?',\n    )\n  }\n  const next = applyMendozaPatch(\n    document,\n    event.effects.apply,\n    event.previousRev,\n  )\n  // next will be undefined in case of deletion\n  return next ? {...next, _rev: event.resultRev} : undefined\n}\n","import {type SanityDocumentBase} from '../../mutations/types'\n\n/**\n * Minimalistic dataset implementation that only supports what's strictly necessary\n */\nexport function createDataset() {\n  const documents = new Map<string, SanityDocumentBase | undefined>()\n  return {\n    set: (id: string, doc: SanityDocumentBase | undefined) =>\n      void documents.set(id, doc),\n    get: (id: string) => documents.get(id),\n    delete: (id: string) => documents.delete(id),\n  }\n}\n","import {finalize, type Observable, ReplaySubject, share, timer} from 'rxjs'\n\nexport function createReplayMemoizer(expiry: number) {\n  const memo: {[key: string]: Observable<any>} = Object.create(null)\n  return function memoize<T>(\n    key: string,\n    observable: Observable<T>,\n  ): Observable<T> {\n    if (!(key in memo)) {\n      memo[key] = observable.pipe(\n        finalize(() => {\n          delete memo[key]\n        }),\n        share({\n          connector: () => new ReplaySubject(1),\n          resetOnRefCountZero: () => timer(expiry),\n        }),\n      )\n    }\n    return memo[key]!\n  }\n}\n","import {type Mutation} from '../../mutations/types'\nimport {type MutationGroup} from '../types'\nimport {getMutationDocumentId} from './getMutationDocumentId'\n\nexport function filterMutationGroupsById(\n  mutationGroups: MutationGroup[],\n  id: string,\n): Mutation[] {\n  return mutationGroups.flatMap(mutationGroup =>\n    mutationGroup.mutations.flatMap(mut =>\n      getMutationDocumentId(mut) === id ? [mut] : [],\n    ),\n  )\n}\n","import {type ReconnectEvent} from '@sanity/client'\nimport {\n  defer,\n  EMPTY,\n  filter,\n  lastValueFrom,\n  map,\n  merge,\n  mergeMap,\n  type Observable,\n  of,\n  Subject,\n  tap,\n  toArray,\n} from 'rxjs'\n\nimport {decodeAll, type SanityMutation} from '../encoders/sanity'\nimport {type Transaction} from '../mutations/types'\nimport {applyMutationEventEffects} from './datasets/applyMendoza'\nimport {applyMutations} from './datasets/applyMutations'\nimport {commit} from './datasets/commit'\nimport {createDataset} from './datasets/createDataset'\nimport {squashDMPStrings} from './optimizations/squashDMPStrings'\nimport {squashMutationGroups} from './optimizations/squashMutations'\nimport {rebase} from './rebase'\nimport {toTransactions} from './toTransactions'\nimport {\n  type ContentLakeStore,\n  type MutationGroup,\n  type OptimisticDocumentEvent,\n  type RemoteDocumentEvent,\n  type RemoteListenerEvent,\n  type RemoteMutationEvent,\n  type SubmitResult,\n  type TransactionalMutationGroup,\n} from './types'\nimport {createReplayMemoizer} from './utils/createReplayMemoizer'\nimport {filterMutationGroupsById} from './utils/filterMutationGroups'\n\nexport interface StoreBackend {\n  /**\n   * Sets up a subscription to a document\n   * The first event should either be a sync event or an error event.\n   * After that, it should emit mutation events, error events or sync events\n   * @param id\n   */\n  observe: (id: string) => Observable<RemoteListenerEvent>\n  submit: (mutationGroups: Transaction[]) => Observable<SubmitResult>\n}\n\nlet didEmitMutationsAccessWarning = false\n// certain components, like the portable text editor, rely on mutations to be present in the event\n// i.e. it's not enough to just have the mendoza-patches.\n// If the listener event did not include mutations (e.g. if excludeMutations was set to true),\n// this warning will be issued if a downstream consumers attempts to access event.mutations\nfunction warnNoMutationsReceived() {\n  if (!didEmitMutationsAccessWarning) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      new Error(\n        'No mutation received from backend. The listener is likely set up with `excludeMutations: true`. If your app need to now about mutations, make sure the listener is set up to include mutations',\n      ),\n    )\n    didEmitMutationsAccessWarning = true\n  }\n}\n\nconst EMPTY_ARRAY: any[] = []\n\nexport function createContentLakeStore(\n  backend: StoreBackend,\n): ContentLakeStore {\n  const local = createDataset()\n  const remote = createDataset()\n  const memoize = createReplayMemoizer(1000)\n  let stagedChanges: MutationGroup[] = []\n\n  const remoteEvents$ = new Subject<RemoteDocumentEvent>()\n  const localMutations$ = new Subject<OptimisticDocumentEvent>()\n\n  const stage$ = new Subject<void>()\n\n  function stage(nextPending: MutationGroup[]) {\n    stagedChanges = nextPending\n    stage$.next()\n  }\n\n  function getLocalEvents(id: string) {\n    return localMutations$.pipe(filter(event => event.id === id))\n  }\n\n  function getRemoteEvents(id: string) {\n    return backend.observe(id).pipe(\n      filter(\n        (event): event is Exclude<RemoteListenerEvent, ReconnectEvent> =>\n          event.type !== 'reconnect',\n      ),\n      mergeMap((event): Observable<RemoteDocumentEvent> => {\n        const oldLocal = local.get(id)\n        const oldRemote = remote.get(id)\n        if (event.type === 'sync') {\n          const newRemote = event.document\n          const [rebasedStage, newLocal] = rebase(\n            id,\n            oldRemote,\n            newRemote,\n            stagedChanges,\n          )\n          return of({\n            type: 'sync',\n            id,\n            before: {remote: oldRemote, local: oldLocal},\n            after: {remote: newRemote, local: newLocal},\n            rebasedStage,\n          })\n        } else if (event.type === 'mutation') {\n          // we have already seen this mutation\n          if (event.transactionId === oldRemote?._rev) {\n            return EMPTY\n          }\n\n          const newRemote = applyMutationEventEffects(oldRemote, event)\n\n          const [rebasedStage, newLocal] = rebase(\n            id,\n            oldRemote,\n            newRemote,\n            stagedChanges,\n          )\n\n          if (newLocal) {\n            newLocal._rev = event.transactionId\n          }\n          const emittedEvent: RemoteMutationEvent = {\n            type: 'mutation',\n            id,\n            rebasedStage,\n            before: {remote: oldRemote, local: oldLocal},\n            after: {remote: newRemote, local: newLocal},\n            effects: event.effects,\n            previousRev: event.previousRev,\n            resultRev: event.resultRev,\n            // overwritten below\n            mutations: EMPTY_ARRAY,\n          }\n          if (event.mutations) {\n            emittedEvent.mutations = decodeAll(\n              event.mutations as SanityMutation[],\n            )\n          } else {\n            Object.defineProperty(\n              emittedEvent,\n              'mutations',\n              warnNoMutationsReceived,\n            )\n          }\n          return of(emittedEvent)\n        } else {\n          // @ts-expect-error should have covered all cases\n          throw new Error(`Unknown event type: ${event.type}`)\n        }\n      }),\n      tap(event => {\n        local.set(event.id, event.after.local)\n        remote.set(event.id, event.after.remote)\n        stage(event.rebasedStage)\n      }),\n      tap({\n        next: event => remoteEvents$.next(event),\n        error: err => {\n          // todo: how to propagate errors?\n          // remoteEvents$.next()\n        },\n      }),\n    )\n  }\n\n  function observeEvents(id: string) {\n    return defer(() =>\n      memoize(id, merge(getLocalEvents(id), getRemoteEvents(id))),\n    )\n  }\n\n  const metaEvents$ = merge(localMutations$, remoteEvents$)\n\n  return {\n    meta: {\n      events: metaEvents$,\n      stage: stage$.pipe(\n        map(\n          () =>\n            // note: this should not be tampered with by consumers. We might want to do a deep-freeze during dev to avoid accidental mutations\n            stagedChanges,\n        ),\n      ),\n      conflicts: EMPTY, // does nothing for now\n    },\n    mutate: mutations => {\n      // add mutations to list of pending changes\n      stagedChanges.push({transaction: false, mutations})\n      // Apply mutations to local dataset (note: this is immutable, and doesn't change the dataset)\n      const results = applyMutations(mutations, local)\n      // Write the updated results back to the \"local\" dataset\n      commit(results, local)\n      results.forEach(result => {\n        localMutations$.next({\n          type: 'optimistic',\n          before: result.before,\n          after: result.after,\n          mutations: result.mutations,\n          id: result.id,\n          stagedChanges: filterMutationGroupsById(stagedChanges, result.id),\n        })\n      })\n      return results\n    },\n    transaction: mutationsOrTransaction => {\n      const transaction: TransactionalMutationGroup = Array.isArray(\n        mutationsOrTransaction,\n      )\n        ? {mutations: mutationsOrTransaction, transaction: true}\n        : {...mutationsOrTransaction, transaction: true}\n\n      stagedChanges.push(transaction)\n      const results = applyMutations(transaction.mutations, local)\n      commit(results, local)\n      results.forEach(result => {\n        localMutations$.next({\n          type: 'optimistic',\n          mutations: result.mutations,\n          id: result.id,\n          before: result.before,\n          after: result.after,\n          stagedChanges: filterMutationGroupsById(stagedChanges, result.id),\n        })\n      })\n      return results\n    },\n    observeEvents,\n    observe: id =>\n      observeEvents(id).pipe(\n        map(event =>\n          event.type === 'optimistic' ? event.after : event.after.local,\n        ),\n      ),\n    optimize: () => {\n      stage(squashMutationGroups(stagedChanges))\n    },\n    submit: () => {\n      const pending = stagedChanges\n      stage([])\n      return lastValueFrom(\n        backend\n          .submit(\n            toTransactions(\n              // Squashing DMP strings is the last thing we do before submitting\n              squashDMPStrings(remote, squashMutationGroups(pending)),\n            ),\n          )\n          .pipe(toArray()),\n      )\n    },\n  }\n}\n"],"names":["applyPatch","finalize","share","ReplaySubject","timer","getMutationDocumentId","Subject","filter","mergeMap","rebase","of","EMPTY","decodeAll","tap","defer","merge","map","applyMutations","commit","squashMutationGroups","lastValueFrom","toTransactions","squashDMPStrings","toArray"],"mappings":"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"}