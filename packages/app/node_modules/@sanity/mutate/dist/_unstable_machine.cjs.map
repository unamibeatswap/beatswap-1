{"version":3,"file":"_unstable_machine.cjs","sources":["../src/machine/listener.ts","../src/machine/documentMutatorMachine.ts"],"sourcesContent":["import {\n  type MutationEvent,\n  type ReconnectEvent,\n  type SanityClient,\n  type WelcomeEvent,\n} from '@sanity/client'\nimport {filter, merge, type ObservedValueOf, share, shareReplay} from 'rxjs'\n\n/**\n * Creates a single, shared, listener EventSource that strems remote mutations, and notifies when it's online (welcome), offline (reconnect).\n */\nexport function createSharedListener(client: SanityClient) {\n  const allEvents$ = client\n    .listen(\n      '*[!(_id in path(\"_.**\"))]',\n      {},\n      {\n        events: ['welcome', 'mutation', 'reconnect'],\n        includeResult: false,\n        includePreviousRevision: false,\n        visibility: 'transaction',\n        effectFormat: 'mendoza',\n        includeMutations: false,\n      },\n    )\n    .pipe(share({resetOnRefCountZero: true}))\n\n  // Reconnect events emitted in case the connection is lost\n  const reconnect = allEvents$.pipe(\n    filter((event): event is ReconnectEvent => event.type === 'reconnect'),\n  )\n\n  // Welcome events are emitted when the listener is (re)connected\n  const welcome = allEvents$.pipe(\n    filter((event): event is WelcomeEvent => event.type === 'welcome'),\n  )\n\n  // Mutation events coming from the listener\n  const mutations = allEvents$.pipe(\n    filter((event): event is MutationEvent => event.type === 'mutation'),\n  )\n\n  // Replay the latest connection event that was emitted either when the connection was disconnected ('reconnect'), established or re-established ('welcome')\n  const connectionEvent = merge(welcome, reconnect).pipe(\n    shareReplay({bufferSize: 1, refCount: true}),\n  )\n\n  // Emit the welcome event if the latest connection event was the 'welcome' event.\n  // Downstream subscribers will typically map the welcome event to an initial fetch\n  const replayWelcome = connectionEvent.pipe(\n    filter(latestConnectionEvent => latestConnectionEvent.type === 'welcome'),\n  )\n\n  // Combine into a single stream\n  return merge(replayWelcome, mutations, reconnect)\n}\n\nexport type SharedListenerEvents = ObservedValueOf<\n  ReturnType<typeof createSharedListener>\n>\n","import {\n  type MutationEvent,\n  type SanityClient,\n  type SanityDocument,\n} from '@sanity/client'\nimport {applyPatch, type RawPatch} from 'mendoza'\nimport {asapScheduler, defer, filter, observeOn} from 'rxjs'\nimport {\n  assertEvent,\n  assign,\n  enqueueActions,\n  fromEventObservable,\n  fromPromise,\n  raise,\n  sendParent,\n  setup,\n  spawnChild,\n  stopChild,\n} from 'xstate'\n\nimport {encodeTransaction, type Mutation} from '../encoders/sanity'\nimport {\n  type MutationGroup,\n  type SanityDocumentBase,\n  type Transaction,\n} from '../store'\nimport {applyMutations} from '../store/datasets/applyMutations'\nimport {commit} from '../store/datasets/commit'\nimport {squashDMPStrings} from '../store/optimizations/squashDMPStrings'\nimport {squashMutationGroups} from '../store/optimizations/squashMutations'\nimport {rebase} from '../store/rebase'\nimport {toTransactions} from '../store/toTransactions'\nimport {createSharedListener, type SharedListenerEvents} from './listener'\n\nexport interface DocumentMutatorMachineInput {\n  id: string\n  client: SanityClient\n  /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n  sharedListener?: ReturnType<typeof createSharedListener>\n  /* Preferrably a LRU cache map that is compatible with an ES6 Map, and have documents that allow unique ids to a particular dataset */\n  cache?: Map<string, SanityDocument<DocumentType> | null>\n}\n\nexport type DocumentMutatorMachineParentEvent =\n  | {type: 'sync'; id: string; document: SanityDocumentBase}\n  | {\n      type: 'mutation'\n      id: string\n      effects: {apply: RawPatch}\n      previousRev: string\n      resultRev: string\n    }\n  | {type: 'rebased.local'; id: string; document: SanityDocumentBase}\n  | {type: 'rebased.remote'; id: string; document: SanityDocumentBase}\n  | {type: 'pristine'; id: string}\n\nexport const documentMutatorMachine = setup({\n  types: {} as {\n    children: {\n      getDocument: 'fetch remote snapshot'\n      submitTransactions: 'submit mutations as transactions'\n    }\n    tags: 'busy' | 'error' | 'ready'\n    context: {\n      client: SanityClient\n      /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n      sharedListener?: ReturnType<typeof createSharedListener>\n      /** The document id */\n      id: string\n      /* Preferrably a LRU cache map that is compatible with an ES6 Map, and have documents that allow unique ids to a particular dataset */\n      cache?: Map<string, SanityDocument<DocumentType> | null>\n      /* The remote snapshot of what the document looks like in Content Lake, kept in sync by applying Mendoza patches in real time. undefined means it's unknown if it exists yet, null means its known that it doesn't exist. */\n      remote: SanityDocument<DocumentType> | null | undefined\n      /* Local snapshot, that is rebased to the remote snapshot whenever that snapshot changes, and allows optimistic local mutations. undefined means it's unknown if the document exists in content lake yet, if both `remote` and `local` is `null` it means it's known that it doesn't exist. If `remote` is defined, and `local` is `null` it means it's optimistically deleted. If `remote` is `null` and `local` defined then it's optimistically created. */\n      local: SanityDocument<DocumentType> | null | undefined\n      /* Remote mendoza mutation events, needs a better name to differentiate from optimistic mutations */\n      mutationEvents: MutationEvent[]\n      /* Track staged mutations that can be submitted */\n      stagedChanges: MutationGroup[]\n      /* Queue mutations mutations that should be staged after an ongoing submission settles */\n      stashedChanges: MutationGroup[]\n      /* Any kind of error object that the UI can parse and decide how to display/report */\n      error: unknown\n      /* Used for automatic retrying of loading the remote snapshot */\n      fetchRemoteSnapshotAttempts: number\n      /* Used for automatic retrying of submitting mutations to Content Lake as a transaction */\n      submitTransactionsAttempts: number\n    }\n    events:\n      | SharedListenerEvents\n      | {type: 'error'}\n      | {type: 'retry'}\n      | {type: 'connect'}\n      | {type: 'reconnect'}\n      | {type: 'welcome'}\n      | {type: 'mutate'; mutations: Mutation[]}\n      | {type: 'submit'}\n      | {\n          type: 'xstate.done.actor.getDocument'\n          output: SanityDocument<DocumentType>\n        }\n      | {\n          type: 'xstate.done.actor.submitTransactions'\n          output: undefined\n        }\n    input: DocumentMutatorMachineInput\n  },\n  actions: {\n    'assign error to context': assign({error: ({event}) => event}),\n    'clear error from context': assign({error: undefined}),\n    'connect to server-sent events': raise({type: 'connect'}),\n    'listen to server-sent events': spawnChild('server-sent events', {\n      id: 'listener',\n      input: ({context}) => ({\n        listener:\n          context.sharedListener || createSharedListener(context.client),\n        id: context.id,\n      }),\n    }),\n    'stop listening to server-sent events': stopChild('listener'),\n    'buffer remote mutation events': assign({\n      mutationEvents: ({event, context}) => {\n        assertEvent(event, 'mutation')\n        return [...context.mutationEvents, event]\n      },\n    }),\n    'restore stashed changes': assign({\n      stagedChanges: ({event, context}) => {\n        assertEvent(event, 'xstate.done.actor.submitTransactions')\n        return context.stashedChanges\n      },\n      stashedChanges: [],\n    }),\n    'rebase fetched remote snapshot': enqueueActions(({enqueue}) => {\n      enqueue.assign(({event, context}) => {\n        assertEvent(event, 'xstate.done.actor.getDocument')\n        const previousRemote = context.remote\n        let nextRemote = event.output\n\n        /**\n         * We assume all patches that happen while we're waiting for the document to resolve are already applied.\n         * But if we do see a patch that has the same revision as the document we just fetched, we should apply any patches following it\n         */\n        let seenCurrentRev = false\n        for (const patch of context.mutationEvents) {\n          if (\n            !patch.effects?.apply ||\n            (!patch.previousRev && patch.transition !== 'appear')\n          )\n            continue\n          if (!seenCurrentRev && patch.previousRev === nextRemote?._rev) {\n            seenCurrentRev = true\n          }\n          if (seenCurrentRev) {\n            nextRemote = applyMendozaPatch(\n              nextRemote,\n              patch.effects.apply,\n              patch.resultRev,\n            )\n          }\n        }\n\n        if (\n          context.cache &&\n          // If the shared cache don't have the document already we can just set it\n          (!context.cache.has(context.id) ||\n            // But when it's in the cache, make sure it's necessary to update it\n            context.cache.get(context.id)!._rev !== nextRemote?._rev)\n        ) {\n          context.cache.set(context.id, nextRemote as unknown as any)\n        }\n\n        const [stagedChanges, local] = rebase(\n          context.id,\n          // It's annoying to convert between null and undefined, reach consensus\n          previousRemote === null ? undefined : previousRemote,\n          nextRemote === null ? undefined : (nextRemote as unknown as any),\n          context.stagedChanges,\n        )\n\n        return {\n          remote: nextRemote as unknown as any,\n          local: local as unknown as any,\n          stagedChanges,\n          // Since the snapshot handler applies all the patches they are no longer needed, allow GC\n          mutationEvents: [],\n        }\n      })\n      enqueue.sendParent(\n        ({context}) =>\n          ({\n            type: 'rebased.remote',\n            id: context.id,\n            document: context.remote!,\n          }) satisfies DocumentMutatorMachineParentEvent,\n      )\n    }),\n    'apply mendoza patch': assign(({event, context}) => {\n      assertEvent(event, 'mutation')\n      const previousRemote = context.remote\n      // We have already seen this mutation\n      if (event.transactionId === previousRemote?._rev) {\n        return {}\n      }\n\n      const nextRemote = applyMendozaPatch(\n        previousRemote!,\n        event.effects!.apply,\n        event.resultRev,\n      )\n\n      if (\n        context.cache &&\n        // If the shared cache don't have the document already we can just set it\n        (!context.cache.has(context.id) ||\n          // But when it's in the cache, make sure it's necessary to update it\n          context.cache.get(context.id)!._rev !== nextRemote?._rev)\n      ) {\n        context.cache.set(context.id, nextRemote as unknown as any)\n      }\n\n      const [stagedChanges, local] = rebase(\n        context.id,\n        // It's annoying to convert between null and undefined, reach consensus\n        previousRemote === null ? undefined : previousRemote,\n        nextRemote === null ? undefined : (nextRemote as unknown as any),\n        context.stagedChanges,\n      )\n\n      return {\n        remote: nextRemote as unknown as any,\n        local: local as unknown as any,\n        stagedChanges,\n      }\n    }),\n    'increment fetch attempts': assign({\n      fetchRemoteSnapshotAttempts: ({context}) =>\n        context.fetchRemoteSnapshotAttempts + 1,\n    }),\n    'reset fetch attempts': assign({\n      fetchRemoteSnapshotAttempts: 0,\n    }),\n    'increment submit attempts': assign({\n      submitTransactionsAttempts: ({context}) =>\n        context.submitTransactionsAttempts + 1,\n    }),\n    'reset submit attempts': assign({\n      submitTransactionsAttempts: 0,\n    }),\n    'stage mutation': assign({\n      stagedChanges: ({event, context}) => {\n        assertEvent(event, 'mutate')\n        return [\n          ...context.stagedChanges,\n          {transaction: false, mutations: event.mutations},\n        ]\n      },\n    }),\n    'stash mutation': assign({\n      stashedChanges: ({event, context}) => {\n        assertEvent(event, 'mutate')\n        return [\n          ...context.stashedChanges,\n          {transaction: false, mutations: event.mutations},\n        ]\n      },\n    }),\n    'rebase local snapshot': enqueueActions(({enqueue}) => {\n      enqueue.assign({\n        local: ({event, context}) => {\n          assertEvent(event, 'mutate')\n          // @TODO would be helpful to not have to convert back and forth between maps\n          const localDataset = new Map()\n          if (context.local) {\n            localDataset.set(context.id, context.local)\n          }\n          // Apply mutations to local dataset (note: this is immutable, and doesn't change the dataset)\n          const results = applyMutations(event.mutations, localDataset)\n          // Write the updated results back to the \"local\" dataset\n          commit(results, localDataset)\n          // Read the result from the local dataset again\n          return localDataset.get(context.id)\n        },\n      })\n      enqueue.sendParent(\n        ({context}) =>\n          ({\n            type: 'rebased.local',\n            id: context.id,\n            document: context.local!,\n          }) satisfies DocumentMutatorMachineParentEvent,\n      )\n    }),\n    'send pristine event to parent': sendParent(\n      ({context}) =>\n        ({\n          type: 'pristine',\n          id: context.id,\n        }) satisfies DocumentMutatorMachineParentEvent,\n    ),\n    'send sync event to parent': sendParent(\n      ({context}) =>\n        ({\n          type: 'sync',\n          id: context.id,\n          document: context.remote!,\n        }) satisfies DocumentMutatorMachineParentEvent,\n    ),\n    'send mutation event to parent': sendParent(({context, event}) => {\n      assertEvent(event, 'mutation')\n      return {\n        type: 'mutation',\n        id: context.id,\n        previousRev: event.previousRev!,\n        resultRev: event.resultRev!,\n        effects: event.effects!,\n      } satisfies DocumentMutatorMachineParentEvent\n    }),\n  },\n  actors: {\n    'server-sent events': fromEventObservable(\n      ({\n        input,\n      }: {\n        input: {listener: ReturnType<typeof createSharedListener>; id: string}\n      }) => {\n        const {listener, id} = input\n        return defer(() => listener).pipe(\n          filter(\n            event =>\n              event.type === 'welcome' ||\n              event.type === 'reconnect' ||\n              (event.type === 'mutation' && event.documentId === id),\n          ),\n          // This is necessary to avoid sync emitted events from `shareReplay` from happening before the actor is ready to receive them\n          observeOn(asapScheduler),\n        )\n      },\n    ),\n    'fetch remote snapshot': fromPromise(\n      async ({\n        input,\n        signal,\n      }: {\n        input: {client: SanityClient; id: string}\n        signal: AbortSignal\n      }) => {\n        const {client, id} = input\n        const document = await client\n          .getDocument(id, {\n            signal,\n          })\n          .catch(e => {\n            if (e instanceof Error && e.name === 'AbortError') return\n            throw e\n          })\n\n        return document\n      },\n    ),\n    'submit mutations as transactions': fromPromise(\n      async ({\n        input,\n        signal,\n      }: {\n        input: {client: SanityClient; transactions: Transaction[]}\n        signal: AbortSignal\n      }) => {\n        const {client, transactions} = input\n        for (const transaction of transactions) {\n          if (signal.aborted) return\n          await client\n            .dataRequest('mutate', encodeTransaction(transaction), {\n              visibility: 'async',\n              returnDocuments: false,\n              signal,\n            })\n            .catch(e => {\n              if (e instanceof Error && e.name === 'AbortError') return\n              throw e\n            })\n        }\n      },\n    ),\n  },\n  delays: {\n    // Exponential backoff delay function\n    fetchRemoteSnapshotTimeout: ({context}) =>\n      Math.pow(2, context.fetchRemoteSnapshotAttempts) * 1000,\n    submitTransactionsTimeout: ({context}) =>\n      Math.pow(2, context.submitTransactionsAttempts) * 1000,\n  },\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QQPYGMCuBbMA7ALgLRYb4CG+KATgMQnn5gDaADALqKgAOKsAlvj4pcnEAA9EADhYAWAHQA2GSwUBmAKwBOaQEZJkhQBoQAT0Q6ATAF8rx1JhwFipCtTkQ+sNMNxg0jCBpvXF9-Vg4kEB5+QWFRCQQLFhY5PQB2dRU1SQsdGSVjMwRlHTkWNM00nR1VKryKmzt0bDwielcqOWDQwVwoGgB3MAAbbxxw0WiBIRFIhPUKuQ1NVU0tTU0WFdVCxAt1dTlNhX2WdRltGUk061sQexandspO7r9e-qo-H3eJyKnYrNQPNJJollpVutNttdghVCo5MoTgoMpo8jIkqpGvdmo42i4Xl0fv4+H0aGAqFRqH9uLxpnE5ogFrCLFd5CtNBYFJkdOpuaosXcHnjnAw3G9-AAxMh8YYYL5BYn4GlROmA+KIFEs1R6ORpZYWHIXGR6bHC1qijpyL4Sj6DEZjZjsSZqmYaxK1ORcvlc-ZqSoyNKwnRpGTyK4WDK5BQ6BQ5BRm3EW55uG1K0n9ClUqgqgFuxketJe7nIv2rUNB0x7LmSL2qGMsSySevcmSJhzJgnipWQOgEma510M4HmcqHZYyWqaOMqTQyWGh0osVSGiwC5uGyftx74sWvHuBNMhX7O-5DoHiPae72lvnlwPBydFlRVS7qPIl7cilP74-+SByMMKBkB4ZKoL4cikgAbigADWYByDA+AACJJgQg4xPmI7FHkZQrKGsjqKcCiaMG9YpJOxySBiCiyPoX6dnuRJ-gEgHAaBmaUm4XDDBQABm1BYIhYAoWhyqnrSmHDpeCAKCicjUbU6g6nkFichYsJrLWVxaPsk7KdICZCmJlqEraAFASBvbPAOEmqlJF4JJURbVDcy4Yvk1GVkUsabApMjKZGqjNg2kgMU8Xa-j0FnsQBXBUJ4vRgH2DBOhEkn0o5TLKV6y6WDG6lhkYVYIDoKzyBkeR8pUDZqOFu5WuZEBsVZzUeFQ+AmDQsAYAARlgAgYZl7o6I2tYLJINSSO+3JaMGlQpGkhFhryo2jW2xkdhFTFNS1EAAT1-UCHa4EIdBcEIYdA34AAKlQZC4LAZAksIsBDeqBbrdpym8iuByxlcLK5BYqQLBUZyTcFvL1aZ3YsTFrVyFdx0ZuSXGdDx-GCUjfXXXdD1PS9j3vVhMnrWCFRxtNaRLdcfIsiwuS5fkgZaOUlhpDDP7MdFzWWftzXI-gdrPGlLoOSNyiHFstRySisjcgzahyFoUYBbRsac5tO6w1F7wIwLONHfg0qyvKyVfPgVAmCT0kJGt41pJD02xgcpElUkcZ6rI+q5JcckbU0W0NWZB57QduMCKbcoKmIsCpXIZB8YwVAABRC-jj3PYCsA3XwOAoKQACUNDmttjVh-zEfG9H5u21lpVjSrTtTTNbsstUYJJAFWgA37XORTz+t8+xtcKpb1v1+6KJFopGQqRi6nBlstYcqNK5riusYDztlejzKMfJXHCdJynqd8SJaAABYAEpgFgKCMAAyrgZBcLAV+P3nBfF6XJnc7tfmY8xZnglgWGe-klILzUhYDSJVRpnCONNOcWxWRKBRDYO4uAUD7XgJEMuIdqDi2GgWQgOhgxMyRKyFc8IuQkXUDvK0HgvAHmIR9bCD4SoeSWCoLkoZpxrmXIw0OLEMxsNJgkSc418KhnrHyG4oZYTcPhMifhJx4SCiDjrABSpgHiLtogAUhwW77DRIGXkk55wexKCrJQsg1jBTnPsYRqZviiL6PohuORgyhhBhGKMsZYzxhcXrf8EBPHulUJOPCtRlABWIu7IoORVBIIhMpNYGJyghKHmEvaYjQEkOwhkxQrJtBES0JDOBPlkgKD1JYZSjZORyTXNkwBsVwkFPYTJVYS58JxPKbOYM0gUj7FjGcEMOpciaJxMHXWOTWJV2avFRKpIwARILJRGJBF4mZBIkDE0KtIxLSSDkDYGhWl70Ru1Tq6zsLURBkoLyWRmz8PmlUZmcY1zXDKdMghcy2mIyFh8W5ZN4RFmOFyKaZwiLeT2GVJcy5pBrguCiMK2tvyDwBYbIWejOkSMQBkeQORJq0RNCUDIDNondxuGpPQmRqIXPhiPECuKMpdMkbILZ-SEnLxyjqOJMZsj1jRTYIAA */\n\n  id: 'document-mutator',\n\n  context: ({input}) => ({\n    client: input.client.withConfig({allowReconfigure: false}),\n    sharedListener: input.sharedListener,\n    id: input.id,\n    remote: undefined,\n    local: undefined,\n    mutationEvents: [],\n    stagedChanges: [],\n    stashedChanges: [],\n    error: undefined,\n    fetchRemoteSnapshotAttempts: 0,\n    submitTransactionsAttempts: 0,\n    cache: input.cache,\n  }),\n\n  // Auto start the connection by default\n  entry: ['connect to server-sent events'],\n\n  on: {\n    mutate: {\n      actions: ['rebase local snapshot', 'stage mutation'],\n    },\n  },\n  initial: 'disconnected',\n  states: {\n    disconnected: {\n      on: {\n        connect: {\n          target: 'connecting',\n          actions: ['listen to server-sent events'],\n        },\n      },\n    },\n    connecting: {\n      on: {\n        welcome: 'connected',\n        reconnect: 'reconnecting',\n        error: 'connectFailure',\n      },\n      tags: ['busy'],\n    },\n    connectFailure: {\n      on: {\n        connect: {\n          target: 'connecting',\n          actions: ['listen to server-sent events'],\n        },\n      },\n      entry: [\n        'stop listening to server-sent events',\n        'assign error to context',\n      ],\n      exit: ['clear error from context'],\n      tags: ['error'],\n    },\n    reconnecting: {\n      on: {\n        welcome: {\n          target: 'connected',\n        },\n        error: {\n          target: 'connectFailure',\n        },\n      },\n      tags: ['busy', 'error'],\n    },\n    connected: {\n      on: {\n        mutation: {\n          actions: ['buffer remote mutation events'],\n        },\n        reconnect: 'reconnecting',\n      },\n      entry: ['clear error from context'],\n      initial: 'loading',\n      states: {\n        loading: {\n          invoke: {\n            src: 'fetch remote snapshot',\n            id: 'getDocument',\n            input: ({context}) => ({\n              client: context.client,\n              id: context.id,\n            }),\n            onError: {\n              target: 'loadFailure',\n            },\n            onDone: {\n              target: 'loaded',\n              actions: [\n                'rebase fetched remote snapshot',\n                'reset fetch attempts',\n              ],\n            },\n          },\n\n          tags: ['busy'],\n        },\n\n        loaded: {\n          entry: ['send sync event to parent'],\n          on: {\n            mutation: {\n              actions: ['apply mendoza patch', 'send mutation event to parent'],\n            },\n          },\n          initial: 'pristine',\n\n          states: {\n            pristine: {\n              on: {\n                mutate: {\n                  actions: ['rebase local snapshot', 'stage mutation'],\n                  target: 'dirty',\n                },\n              },\n              tags: ['ready'],\n            },\n            dirty: {\n              on: {\n                submit: 'submitting',\n              },\n              tags: ['ready'],\n            },\n            submitting: {\n              on: {\n                mutate: {\n                  actions: ['rebase local snapshot', 'stash mutation'],\n                },\n              },\n              invoke: {\n                src: 'submit mutations as transactions',\n                id: 'submitTransactions',\n                input: ({context}) => {\n                  // @TODO perhaps separate utils to be lower level and operate on single documents at a time instead of expecting a local dataset\n                  const remoteDataset = new Map()\n                  remoteDataset.set(context.id, context.remote)\n                  return {\n                    client: context.client,\n                    transactions: toTransactions(\n                      // Squashing DMP strings is the last thing we do before submitting\n                      squashDMPStrings(\n                        remoteDataset,\n                        squashMutationGroups(context.stagedChanges),\n                      ),\n                    ),\n                  }\n                },\n                onError: {\n                  target: 'submitFailure',\n                },\n\n                onDone: {\n                  target: 'pristine',\n                  actions: [\n                    'restore stashed changes',\n                    'reset submit attempts',\n                    'send pristine event to parent',\n                  ],\n                },\n              },\n              /**\n               * 'busy' means we should show a spinner, 'ready' means we can still accept mutations, they'll be applied optimistically right away, and queued for submissions after the current submission settles\n               */\n              tags: ['busy', 'ready'],\n            },\n            submitFailure: {\n              exit: ['clear error from context'],\n              after: {\n                submitTransactionsTimeout: {\n                  actions: ['increment submit attempts'],\n                  target: 'submitting',\n                },\n              },\n              on: {\n                retry: 'submitting',\n              },\n              /**\n               * How can it be both `ready` and `error`? `ready` means it can receive mutations, optimistically apply them, and queue them for submission. `error` means it failed to submit previously applied mutations.\n               * It's completely fine to keep queueing up more mutations and applying them optimistically, while showing UI that notifies that mutations didn't submit, and show a count down until the next automatic retry.\n               */\n              tags: ['error', 'ready'],\n            },\n          },\n        },\n\n        loadFailure: {\n          exit: ['clear error from context'],\n          after: {\n            fetchRemoteSnapshotTimeout: {\n              actions: ['increment fetch attempts'],\n              target: 'loading',\n            },\n          },\n          on: {\n            retry: 'loading',\n          },\n          tags: ['error'],\n        },\n      },\n    },\n  },\n})\n\nfunction applyMendozaPatch<const DocumentType extends SanityDocumentBase>(\n  document: DocumentType | undefined,\n  patch: RawPatch,\n  nextRevision: string | undefined,\n) {\n  const next = applyPatch(omitRev(document), patch)\n  if (!next) {\n    return null\n  }\n  return Object.assign(next, {_rev: nextRevision})\n}\n\nfunction omitRev<const DocumentType extends SanityDocumentBase>(\n  document: DocumentType | undefined,\n) {\n  if (!document) {\n    return null\n  }\n  // eslint-disable-next-line unused-imports/no-unused-vars\n  const {_rev, ...doc} = document\n  return doc\n}\n"],"names":["share","filter","merge","shareReplay","setup","assign","raise","spawnChild","stopChild","assertEvent","enqueueActions","rebase","applyMutations","commit","sendParent","fromEventObservable","defer","observeOn","asapScheduler","fromPromise","encodeTransaction","toTransactions","squashDMPStrings","squashMutationGroups","applyPatch"],"mappings":"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"}