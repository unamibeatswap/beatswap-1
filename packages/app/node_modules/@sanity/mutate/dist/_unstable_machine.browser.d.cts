import {ActorRef} from 'xstate'
import {ActorRefFromLogic} from 'xstate'
import {AnyActorLogic} from 'xstate'
import {AnyActorRef} from 'xstate'
import {AnyEventObject} from 'xstate'
import {ConditionalRequired} from 'xstate'
import {EventObject} from 'xstate'
import {GetConcreteByKey} from 'xstate'
import {InputFrom} from 'xstate'
import {IsNotNever} from 'xstate'
import {MachineSnapshot} from 'xstate'
import {MetaObject} from 'xstate'
import {MutationEvent as MutationEvent_2} from '@sanity/client'
import {NonReducibleUnknown} from 'xstate'
import {Observable} from 'rxjs'
import {ObservableActorLogic} from 'xstate'
import {ObservedValueOf} from 'rxjs'
import {PromiseActorLogic} from 'xstate'
import {ReconnectEvent} from '@sanity/client'
import {RequiredActorOptions} from 'xstate'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/client'
import {StateMachine} from 'xstate'
import {StateValue} from 'xstate'
import {Values} from 'xstate'
import {WelcomeEvent} from '@sanity/client'

export declare type AnyArray<T = any> = T[] | readonly T[]

export declare type AnyEmptyArray = [] | readonly []

export declare type AnyOp = SetOp<unknown> | SetIfMissingOp<unknown> | UnsetOp

/**
 * Takes a list of mutations and applies them to documents in a dataset
 */
export declare function applyMutations<T extends SanityDocumentBase>(
  mutations: Mutation[],
  dataset: {
    get: (id: string) => T | undefined
  },
): UpdateResult<T>[]

export declare type ArrayOp =
  | InsertOp<AnyArray, RelativePosition, Index | KeyedPathElement>
  | UpsertOp<AnyArray, RelativePosition, Index | KeyedPathElement>
  | ReplaceOp<AnyArray, Index | KeyedPathElement>
  | TruncateOp
  | RemoveOp<Index | KeyedPathElement>

export declare type AssignOp<T extends object = object> = {
  type: 'assign'
  value: T
}

export declare type ByIndex<P extends number, T extends AnyArray> = T[P]

export declare function commit<Doc extends SanityDocumentBase>(
  results: UpdateResult<Doc>[],
  dataset: Dataset<Doc>,
): void

export declare type Concat<
  R extends Result<any, any>,
  Arr extends any[],
> = R[1] extends any[] ? Ok<[...R[1], ...Arr]> : R

export declare type ConcatInner<
  R extends Result<any, any>,
  R2 extends Result<any, any>,
> = R2[1] extends any[] ? Concat<R, R2[1]> : R2

export declare type CreateIfNotExistsMutation<Doc extends SanityDocumentBase> =
  {
    type: 'createIfNotExists'
    document: Doc
  }

export declare type CreateMutation<
  Doc extends Optional<SanityDocumentBase, '_id'>,
> = {
  type: 'create'
  document: Doc
}

export declare type CreateOrReplaceMutation<Doc extends SanityDocumentBase> = {
  type: 'createOrReplace'
  document: Doc
}

/**
 * Creates a single, shared, listener EventSource that strems remote mutations, and notifies when it's online (welcome), offline (reconnect).
 */
export declare function createSharedListener(
  client: SanityClient,
): Observable<ReconnectEvent | WelcomeEvent | MutationEvent_2>

export declare type Dataset<Doc extends SanityDocumentBase> = {
  get(id: string): Doc | undefined
  set(id: string, doc: Doc | undefined): void
  delete(id: string): void
}

export declare interface DataStore {
  get: (id: string) => SanityDocumentBase | undefined
}

export declare type DecOp<Amount extends number> = {
  type: 'dec'
  amount: Amount
}

export declare type DeleteMutation = {
  type: 'delete'
  id: string
}

export declare type DiffMatchPatchOp = {
  type: 'diffMatchPatch'
  value: string
}

export declare type Digit =
  | '0'
  | '1'
  | '2'
  | '3'
  | '4'
  | '5'
  | '6'
  | '7'
  | '8'
  | '9'

export declare const documentMutatorMachine: StateMachine<
  {
    client: SanityClient
    /** A shared listener can be provided, if not it'll be created using `client.listen()` */
    sharedListener?: ReturnType<typeof createSharedListener>
    /** The document id */
    id: string
    cache?: Map<string, SanityDocument<DocumentType> | null>
    remote: SanityDocument<DocumentType> | null | undefined
    local: SanityDocument<DocumentType> | null | undefined
    mutationEvents: MutationEvent_2[]
    stagedChanges: MutationGroup[]
    stashedChanges: MutationGroup[]
    error: unknown
    fetchRemoteSnapshotAttempts: number
    submitTransactionsAttempts: number
  },
  | ReconnectEvent
  | WelcomeEvent
  | MutationEvent_2
  | {
      type: 'error'
    }
  | {
      type: 'retry'
    }
  | {
      type: 'connect'
    }
  | {
      type: 'reconnect'
    }
  | {
      type: 'welcome'
    }
  | {
      type: 'mutate'
      mutations: Mutation[]
    }
  | {
      type: 'submit'
    }
  | {
      type: 'xstate.done.actor.getDocument'
      output: SanityDocument<DocumentType>
    }
  | {
      type: 'xstate.done.actor.submitTransactions'
      output: undefined
    },
  {
    [x: string]:
      | ActorRefFromLogic<
          PromiseActorLogic<
            void | SanityDocument<Record<string, any>> | undefined,
            {
              client: SanityClient
              id: string
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            void,
            {
              client: SanityClient
              transactions: Transaction[]
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          ObservableActorLogic<
            ReconnectEvent | WelcomeEvent | MutationEvent_2,
            {
              listener: ReturnType<typeof createSharedListener>
              id: string
            },
            EventObject
          >
        >
      | undefined
    getDocument?:
      | ActorRefFromLogic<
          PromiseActorLogic<
            void | SanityDocument<Record<string, any>> | undefined,
            {
              client: SanityClient
              id: string
            },
            EventObject
          >
        >
      | undefined
    submitTransactions?:
      | ActorRefFromLogic<
          PromiseActorLogic<
            void,
            {
              client: SanityClient
              transactions: Transaction[]
            },
            EventObject
          >
        >
      | undefined
  },
  Values<{
    'fetch remote snapshot': {
      src: 'fetch remote snapshot'
      logic: PromiseActorLogic<
        void | SanityDocument<Record<string, any>> | undefined,
        {
          client: SanityClient
          id: string
        },
        EventObject
      >
      id: 'getDocument'
    }
    'submit mutations as transactions': {
      src: 'submit mutations as transactions'
      logic: PromiseActorLogic<
        void,
        {
          client: SanityClient
          transactions: Transaction[]
        },
        EventObject
      >
      id: 'submitTransactions'
    }
    'server-sent events': {
      src: 'server-sent events'
      logic: ObservableActorLogic<
        ReconnectEvent | WelcomeEvent | MutationEvent_2,
        {
          listener: ReturnType<typeof createSharedListener>
          id: string
        },
        EventObject
      >
      id: string | undefined
    }
  }>,
  Values<{
    'assign error to context': {
      type: 'assign error to context'
      params: NonReducibleUnknown
    }
    'clear error from context': {
      type: 'clear error from context'
      params: NonReducibleUnknown
    }
    'connect to server-sent events': {
      type: 'connect to server-sent events'
      params: NonReducibleUnknown
    }
    'listen to server-sent events': {
      type: 'listen to server-sent events'
      params: NonReducibleUnknown
    }
    'stop listening to server-sent events': {
      type: 'stop listening to server-sent events'
      params: NonReducibleUnknown
    }
    'buffer remote mutation events': {
      type: 'buffer remote mutation events'
      params: NonReducibleUnknown
    }
    'restore stashed changes': {
      type: 'restore stashed changes'
      params: NonReducibleUnknown
    }
    'rebase fetched remote snapshot': {
      type: 'rebase fetched remote snapshot'
      params: NonReducibleUnknown
    }
    'apply mendoza patch': {
      type: 'apply mendoza patch'
      params: NonReducibleUnknown
    }
    'increment fetch attempts': {
      type: 'increment fetch attempts'
      params: NonReducibleUnknown
    }
    'reset fetch attempts': {
      type: 'reset fetch attempts'
      params: NonReducibleUnknown
    }
    'increment submit attempts': {
      type: 'increment submit attempts'
      params: NonReducibleUnknown
    }
    'reset submit attempts': {
      type: 'reset submit attempts'
      params: NonReducibleUnknown
    }
    'stage mutation': {
      type: 'stage mutation'
      params: NonReducibleUnknown
    }
    'stash mutation': {
      type: 'stash mutation'
      params: NonReducibleUnknown
    }
    'rebase local snapshot': {
      type: 'rebase local snapshot'
      params: NonReducibleUnknown
    }
    'send pristine event to parent': {
      type: 'send pristine event to parent'
      params: NonReducibleUnknown
    }
    'send sync event to parent': {
      type: 'send sync event to parent'
      params: NonReducibleUnknown
    }
    'send mutation event to parent': {
      type: 'send mutation event to parent'
      params: NonReducibleUnknown
    }
  }>,
  never,
  'fetchRemoteSnapshotTimeout' | 'submitTransactionsTimeout',
  | 'disconnected'
  | 'connecting'
  | 'reconnecting'
  | 'connectFailure'
  | {
      connected:
        | 'loading'
        | 'loadFailure'
        | {
            loaded: 'pristine' | 'dirty' | 'submitting' | 'submitFailure'
          }
    },
  'error' | 'busy' | 'ready',
  DocumentMutatorMachineInput,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    /** @xstate-layout N4IgpgJg5mDOIC5QQPYGMCuBbMA7ALgLRYb4CG+KATgMQnn5gDaADALqKgAOKsAlvj4pcnEAA9EADhYAWAHQA2GSwUBmAKwBOaQEZJkhQBoQAT0Q6ATAF8rx1JhwFipCtTkQ+sNMNxg0jCBpvXF9-Vg4kEB5+QWFRCQQLFhY5PQB2dRU1SQsdGSVjMwRlHTkWNM00nR1VKryKmzt0bDwielcqOWDQwVwoGgB3MAAbbxxw0WiBIRFIhPUKuQ1NVU0tTU0WFdVCxAt1dTlNhX2WdRltGUk061sQexandspO7r9e-qo-H3eJyKnYrNQPNJJollpVutNttdghVCo5MoTgoMpo8jIkqpGvdmo42i4Xl0fv4+H0aGAqFRqH9uLxpnE5ogFrCLFd5CtNBYFJkdOpuaosXcHnjnAw3G9-AAxMh8YYYL5BYn4GlROmA+KIFEs1R6ORpZYWHIXGR6bHC1qijpyL4Sj6DEZjZjsSZqmYaxK1ORcvlc-ZqSoyNKwnRpGTyK4WDK5BQ6BQ5BRm3EW55uG1K0n9ClUqgqgFuxketJe7nIv2rUNB0x7LmSL2qGMsSySevcmSJhzJgnipWQOgEma510M4HmcqHZYyWqaOMqTQyWGh0osVSGiwC5uGyftx74sWvHuBNMhX7O-5DoHiPae72lvnlwPBydFlRVS7qPIl7cilP74-+SByMMKBkB4ZKoL4cikgAbigADWYByDA+AACJJgQg4xPmI7FHkZQrKGsjqKcCiaMG9YpJOxySBiCiyPoX6dnuRJ-gEgHAaBmaUm4XDDBQABm1BYIhYAoWhyqnrSmHDpeCAKCicjUbU6g6nkFichYsJrLWVxaPsk7KdICZCmJlqEraAFASBvbPAOEmqlJF4JJURbVDcy4Yvk1GVkUsabApMjKZGqjNg2kgMU8Xa-j0FnsQBXBUJ4vRgH2DBOhEkn0o5TLKV6y6WDG6lhkYVYIDoKzyBkeR8pUDZqOFu5WuZEBsVZzUeFQ+AmDQsAYAARlgAgYZl7o6I2tYLJINSSO+3JaMGlQpGkhFhryo2jW2xkdhFTFNS1EAAT1-UCHa4EIdBcEIYdA34AAKlQZC4LAZAksIsBDeqBbrdpym8iuByxlcLK5BYqQLBUZyTcFvL1aZ3YsTFrVyFdx0ZuSXGdDx-GCUjfXXXdD1PS9j3vVhMnrWCFRxtNaRLdcfIsiwuS5fkgZaOUlhpDDP7MdFzWWftzXI-gdrPGlLoOSNyiHFstRySisjcgzahyFoUYBbRsac5tO6w1F7wIwLONHfg0qyvKyVfPgVAmCT0kJGt41pJD02xgcpElUkcZ6rI+q5JcckbU0W0NWZB57QduMCKbcoKmIsCpXIZB8YwVAABRC-jj3PYCsA3XwOAoKQACUNDmttjVh-zEfG9H5u21lpVjSrTtTTNbsstUYJJAFWgA37XORTz+t8+xtcKpb1v1+6KJFopGQqRi6nBlstYcqNK5riusYDztlejzKMfJXHCdJynqd8SJaAABYAEpgFgKCMAAyrgZBcLAV+P3nBfF6XJnc7tfmY8xZnglgWGe-klILzUhYDSJVRpnCONNOcWxWRKBRDYO4uAUD7XgJEMuIdqDi2GgWQgOhgxMyRKyFc8IuQkXUDvK0HgvAHmIR9bCD4SoeSWCoLkoZpxrmXIw0OLEMxsNJgkSc418KhnrHyG4oZYTcPhMifhJx4SCiDjrABSpgHiLtogAUhwW77DRIGXkk55wexKCrJQsg1jBTnPsYRqZviiL6PohuORgyhhBhGKMsZYzxhcXrf8EBPHulUJOPCtRlABWIu7IoORVBIIhMpNYGJyghKHmEvaYjQEkOwhkxQrJtBES0JDOBPlkgKD1JYZSjZORyTXNkwBsVwkFPYTJVYS58JxPKbOYM0gUj7FjGcEMOpciaJxMHXWOTWJV2avFRKpIwARILJRGJBF4mZBIkDE0KtIxLSSDkDYGhWl70Ru1Tq6zsLURBkoLyWRmz8PmlUZmcY1zXDKdMghcy2mIyFh8W5ZN4RFmOFyKaZwiLeT2GVJcy5pBrguCiMK2tvyDwBYbIWejOkSMQBkeQORJq0RNCUDIDNondxuGpPQmRqIXPhiPECuKMpdMkbILZ-SEnLxyjqOJMZsj1jRTYIAA */
    readonly id: 'document-mutator'
    readonly context: ({
      input,
    }: {
      spawn: {
        <
          TSrc extends
            | 'fetch remote snapshot'
            | 'submit mutations as transactions'
            | 'server-sent events',
        >(
          logic: TSrc,
          ...[options]:
            | ({
                src: 'fetch remote snapshot'
                logic: PromiseActorLogic<
                  void | SanityDocument<Record<string, any>> | undefined,
                  {
                    client: SanityClient
                    id: string
                  },
                  EventObject
                >
                id: 'getDocument'
              } extends infer T
                ? T extends {
                    src: 'fetch remote snapshot'
                    logic: PromiseActorLogic<
                      void | SanityDocument<Record<string, any>> | undefined,
                      {
                        client: SanityClient
                        id: string
                      },
                      EventObject
                    >
                    id: 'getDocument'
                  }
                  ? T extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K in RequiredActorOptions<T>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'submit mutations as transactions'
                logic: PromiseActorLogic<
                  void,
                  {
                    client: SanityClient
                    transactions: Transaction[]
                  },
                  EventObject
                >
                id: 'submitTransactions'
              } extends infer T_1
                ? T_1 extends {
                    src: 'submit mutations as transactions'
                    logic: PromiseActorLogic<
                      void,
                      {
                        client: SanityClient
                        transactions: Transaction[]
                      },
                      EventObject
                    >
                    id: 'submitTransactions'
                  }
                  ? T_1 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_1['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_1['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_1 in RequiredActorOptions<T_1>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_1>>
                      >
                    : never
                  : never
                : never)
            | ({
                src: 'server-sent events'
                logic: ObservableActorLogic<
                  ReconnectEvent | WelcomeEvent | MutationEvent_2,
                  {
                    listener: ReturnType<typeof createSharedListener>
                    id: string
                  },
                  EventObject
                >
                id: string | undefined
              } extends infer T_2
                ? T_2 extends {
                    src: 'server-sent events'
                    logic: ObservableActorLogic<
                      ReconnectEvent | WelcomeEvent | MutationEvent_2,
                      {
                        listener: ReturnType<typeof createSharedListener>
                        id: string
                      },
                      EventObject
                    >
                    id: string | undefined
                  }
                  ? T_2 extends {
                      src: TSrc
                    }
                    ? ConditionalRequired<
                        [
                          options?:
                            | ({
                                id?: T_2['id'] | undefined
                                systemId?: string
                                input?: InputFrom<T_2['logic']> | undefined
                                syncSnapshot?: boolean
                              } & {[K_2 in RequiredActorOptions<T_2>]: unknown})
                            | undefined,
                        ],
                        IsNotNever<RequiredActorOptions<T_2>>
                      >
                    : never
                  : never
                : never)
        ): ActorRefFromLogic<
          GetConcreteByKey<
            Values<{
              'fetch remote snapshot': {
                src: 'fetch remote snapshot'
                logic: PromiseActorLogic<
                  void | SanityDocument<Record<string, any>> | undefined,
                  {
                    client: SanityClient
                    id: string
                  },
                  EventObject
                >
                id: 'getDocument'
              }
              'submit mutations as transactions': {
                src: 'submit mutations as transactions'
                logic: PromiseActorLogic<
                  void,
                  {
                    client: SanityClient
                    transactions: Transaction[]
                  },
                  EventObject
                >
                id: 'submitTransactions'
              }
              'server-sent events': {
                src: 'server-sent events'
                logic: ObservableActorLogic<
                  ReconnectEvent | WelcomeEvent | MutationEvent_2,
                  {
                    listener: ReturnType<typeof createSharedListener>
                    id: string
                  },
                  EventObject
                >
                id: string | undefined
              }
            }>,
            'src',
            TSrc
          >['logic']
        >
        <TLogic extends AnyActorLogic>(
          src: TLogic,
          options?:
            | {
                id?: never
                systemId?: string
                input?: InputFrom<TLogic> | undefined
                syncSnapshot?: boolean
              }
            | undefined,
        ): ActorRefFromLogic<TLogic>
      }
      input: DocumentMutatorMachineInput
      self: ActorRef<
        MachineSnapshot<
          {
            client: SanityClient
            /** A shared listener can be provided, if not it'll be created using `client.listen()` */
            sharedListener?: ReturnType<typeof createSharedListener>
            /** The document id */
            id: string
            cache?: Map<string, SanityDocument<DocumentType> | null>
            remote: SanityDocument<DocumentType> | null | undefined
            local: SanityDocument<DocumentType> | null | undefined
            mutationEvents: MutationEvent_2[]
            stagedChanges: MutationGroup[]
            stashedChanges: MutationGroup[]
            error: unknown
            fetchRemoteSnapshotAttempts: number
            submitTransactionsAttempts: number
          },
          | ReconnectEvent
          | WelcomeEvent
          | MutationEvent_2
          | {
              type: 'error'
            }
          | {
              type: 'retry'
            }
          | {
              type: 'connect'
            }
          | {
              type: 'reconnect'
            }
          | {
              type: 'welcome'
            }
          | {
              type: 'mutate'
              mutations: Mutation[]
            }
          | {
              type: 'submit'
            }
          | {
              type: 'xstate.done.actor.getDocument'
              output: SanityDocument<DocumentType>
            }
          | {
              type: 'xstate.done.actor.submitTransactions'
              output: undefined
            },
          Record<string, AnyActorRef | undefined>,
          StateValue,
          string,
          unknown,
          any,
          any
        >,
        | ReconnectEvent
        | WelcomeEvent
        | MutationEvent_2
        | {
            type: 'error'
          }
        | {
            type: 'retry'
          }
        | {
            type: 'connect'
          }
        | {
            type: 'reconnect'
          }
        | {
            type: 'welcome'
          }
        | {
            type: 'mutate'
            mutations: Mutation[]
          }
        | {
            type: 'submit'
          }
        | {
            type: 'xstate.done.actor.getDocument'
            output: SanityDocument<DocumentType>
          }
        | {
            type: 'xstate.done.actor.submitTransactions'
            output: undefined
          },
        AnyEventObject
      >
    }) => {
      client: SanityClient
      sharedListener:
        | Observable<ReconnectEvent | WelcomeEvent | MutationEvent_2>
        | undefined
      id: string
      remote: undefined
      local: undefined
      mutationEvents: never[]
      stagedChanges: never[]
      stashedChanges: never[]
      error: undefined
      fetchRemoteSnapshotAttempts: number
      submitTransactionsAttempts: number
      cache: Map<string, SanityDocument<DocumentType> | null> | undefined
    }
    readonly entry: readonly ['connect to server-sent events']
    readonly on: {
      readonly mutate: {
        readonly actions: readonly ['rebase local snapshot', 'stage mutation']
      }
    }
    readonly initial: 'disconnected'
    readonly states: {
      readonly disconnected: {
        readonly on: {
          readonly connect: {
            readonly target: 'connecting'
            readonly actions: readonly ['listen to server-sent events']
          }
        }
      }
      readonly connecting: {
        readonly on: {
          readonly welcome: 'connected'
          readonly reconnect: 'reconnecting'
          readonly error: 'connectFailure'
        }
        readonly tags: readonly ['busy']
      }
      readonly connectFailure: {
        readonly on: {
          readonly connect: {
            readonly target: 'connecting'
            readonly actions: readonly ['listen to server-sent events']
          }
        }
        readonly entry: readonly [
          'stop listening to server-sent events',
          'assign error to context',
        ]
        readonly exit: readonly ['clear error from context']
        readonly tags: readonly ['error']
      }
      readonly reconnecting: {
        readonly on: {
          readonly welcome: {
            readonly target: 'connected'
          }
          readonly error: {
            readonly target: 'connectFailure'
          }
        }
        readonly tags: readonly ['busy', 'error']
      }
      readonly connected: {
        readonly on: {
          readonly mutation: {
            readonly actions: readonly ['buffer remote mutation events']
          }
          readonly reconnect: 'reconnecting'
        }
        readonly entry: readonly ['clear error from context']
        readonly initial: 'loading'
        readonly states: {
          readonly loading: {
            readonly invoke: {
              readonly src: 'fetch remote snapshot'
              readonly id: 'getDocument'
              readonly input: ({
                context,
              }: {
                context: {
                  client: SanityClient
                  /** A shared listener can be provided, if not it'll be created using `client.listen()` */
                  sharedListener?: ReturnType<typeof createSharedListener>
                  /** The document id */
                  id: string
                  cache?: Map<string, SanityDocument<DocumentType> | null>
                  remote: SanityDocument<DocumentType> | null | undefined
                  local: SanityDocument<DocumentType> | null | undefined
                  mutationEvents: MutationEvent_2[]
                  stagedChanges: MutationGroup[]
                  stashedChanges: MutationGroup[]
                  error: unknown
                  fetchRemoteSnapshotAttempts: number
                  submitTransactionsAttempts: number
                }
                event:
                  | ReconnectEvent
                  | WelcomeEvent
                  | MutationEvent_2
                  | {
                      type: 'error'
                    }
                  | {
                      type: 'retry'
                    }
                  | {
                      type: 'connect'
                    }
                  | {
                      type: 'reconnect'
                    }
                  | {
                      type: 'welcome'
                    }
                  | {
                      type: 'mutate'
                      mutations: Mutation[]
                    }
                  | {
                      type: 'submit'
                    }
                  | {
                      type: 'xstate.done.actor.getDocument'
                      output: SanityDocument<DocumentType>
                    }
                  | {
                      type: 'xstate.done.actor.submitTransactions'
                      output: undefined
                    }
                self: ActorRef<
                  MachineSnapshot<
                    {
                      client: SanityClient
                      /** A shared listener can be provided, if not it'll be created using `client.listen()` */
                      sharedListener?: ReturnType<typeof createSharedListener>
                      /** The document id */
                      id: string
                      cache?: Map<string, SanityDocument<DocumentType> | null>
                      remote: SanityDocument<DocumentType> | null | undefined
                      local: SanityDocument<DocumentType> | null | undefined
                      mutationEvents: MutationEvent_2[]
                      stagedChanges: MutationGroup[]
                      stashedChanges: MutationGroup[]
                      error: unknown
                      fetchRemoteSnapshotAttempts: number
                      submitTransactionsAttempts: number
                    },
                    | ReconnectEvent
                    | WelcomeEvent
                    | MutationEvent_2
                    | {
                        type: 'error'
                      }
                    | {
                        type: 'retry'
                      }
                    | {
                        type: 'connect'
                      }
                    | {
                        type: 'reconnect'
                      }
                    | {
                        type: 'welcome'
                      }
                    | {
                        type: 'mutate'
                        mutations: Mutation[]
                      }
                    | {
                        type: 'submit'
                      }
                    | {
                        type: 'xstate.done.actor.getDocument'
                        output: SanityDocument<DocumentType>
                      }
                    | {
                        type: 'xstate.done.actor.submitTransactions'
                        output: undefined
                      },
                    Record<string, AnyActorRef>,
                    StateValue,
                    string,
                    unknown,
                    any,
                    any
                  >,
                  | ReconnectEvent
                  | WelcomeEvent
                  | MutationEvent_2
                  | {
                      type: 'error'
                    }
                  | {
                      type: 'retry'
                    }
                  | {
                      type: 'connect'
                    }
                  | {
                      type: 'reconnect'
                    }
                  | {
                      type: 'welcome'
                    }
                  | {
                      type: 'mutate'
                      mutations: Mutation[]
                    }
                  | {
                      type: 'submit'
                    }
                  | {
                      type: 'xstate.done.actor.getDocument'
                      output: SanityDocument<DocumentType>
                    }
                  | {
                      type: 'xstate.done.actor.submitTransactions'
                      output: undefined
                    },
                  AnyEventObject
                >
              }) => {
                client: SanityClient
                id: string
              }
              readonly onError: {
                readonly target: 'loadFailure'
              }
              readonly onDone: {
                readonly target: 'loaded'
                readonly actions: readonly [
                  'rebase fetched remote snapshot',
                  'reset fetch attempts',
                ]
              }
            }
            readonly tags: readonly ['busy']
          }
          readonly loaded: {
            readonly entry: readonly ['send sync event to parent']
            readonly on: {
              readonly mutation: {
                readonly actions: readonly [
                  'apply mendoza patch',
                  'send mutation event to parent',
                ]
              }
            }
            readonly initial: 'pristine'
            readonly states: {
              readonly pristine: {
                readonly on: {
                  readonly mutate: {
                    readonly actions: readonly [
                      'rebase local snapshot',
                      'stage mutation',
                    ]
                    readonly target: 'dirty'
                  }
                }
                readonly tags: readonly ['ready']
              }
              readonly dirty: {
                readonly on: {
                  readonly submit: 'submitting'
                }
                readonly tags: readonly ['ready']
              }
              readonly submitting: {
                readonly on: {
                  readonly mutate: {
                    readonly actions: readonly [
                      'rebase local snapshot',
                      'stash mutation',
                    ]
                  }
                }
                readonly invoke: {
                  readonly src: 'submit mutations as transactions'
                  readonly id: 'submitTransactions'
                  readonly input: ({
                    context,
                  }: {
                    context: {
                      client: SanityClient
                      /** A shared listener can be provided, if not it'll be created using `client.listen()` */
                      sharedListener?: ReturnType<typeof createSharedListener>
                      /** The document id */
                      id: string
                      cache?: Map<string, SanityDocument<DocumentType> | null>
                      remote: SanityDocument<DocumentType> | null | undefined
                      local: SanityDocument<DocumentType> | null | undefined
                      mutationEvents: MutationEvent_2[]
                      stagedChanges: MutationGroup[]
                      stashedChanges: MutationGroup[]
                      error: unknown
                      fetchRemoteSnapshotAttempts: number
                      submitTransactionsAttempts: number
                    }
                    event:
                      | ReconnectEvent
                      | WelcomeEvent
                      | MutationEvent_2
                      | {
                          type: 'error'
                        }
                      | {
                          type: 'retry'
                        }
                      | {
                          type: 'connect'
                        }
                      | {
                          type: 'reconnect'
                        }
                      | {
                          type: 'welcome'
                        }
                      | {
                          type: 'mutate'
                          mutations: Mutation[]
                        }
                      | {
                          type: 'submit'
                        }
                      | {
                          type: 'xstate.done.actor.getDocument'
                          output: SanityDocument<DocumentType>
                        }
                      | {
                          type: 'xstate.done.actor.submitTransactions'
                          output: undefined
                        }
                    self: ActorRef<
                      MachineSnapshot<
                        {
                          client: SanityClient
                          /** A shared listener can be provided, if not it'll be created using `client.listen()` */
                          sharedListener?: ReturnType<
                            typeof createSharedListener
                          >
                          /** The document id */
                          id: string
                          cache?: Map<
                            string,
                            SanityDocument<DocumentType> | null
                          >
                          remote:
                            | SanityDocument<DocumentType>
                            | null
                            | undefined
                          local: SanityDocument<DocumentType> | null | undefined
                          mutationEvents: MutationEvent_2[]
                          stagedChanges: MutationGroup[]
                          stashedChanges: MutationGroup[]
                          error: unknown
                          fetchRemoteSnapshotAttempts: number
                          submitTransactionsAttempts: number
                        },
                        | ReconnectEvent
                        | WelcomeEvent
                        | MutationEvent_2
                        | {
                            type: 'error'
                          }
                        | {
                            type: 'retry'
                          }
                        | {
                            type: 'connect'
                          }
                        | {
                            type: 'reconnect'
                          }
                        | {
                            type: 'welcome'
                          }
                        | {
                            type: 'mutate'
                            mutations: Mutation[]
                          }
                        | {
                            type: 'submit'
                          }
                        | {
                            type: 'xstate.done.actor.getDocument'
                            output: SanityDocument<DocumentType>
                          }
                        | {
                            type: 'xstate.done.actor.submitTransactions'
                            output: undefined
                          },
                        Record<string, AnyActorRef>,
                        StateValue,
                        string,
                        unknown,
                        any,
                        any
                      >,
                      | ReconnectEvent
                      | WelcomeEvent
                      | MutationEvent_2
                      | {
                          type: 'error'
                        }
                      | {
                          type: 'retry'
                        }
                      | {
                          type: 'connect'
                        }
                      | {
                          type: 'reconnect'
                        }
                      | {
                          type: 'welcome'
                        }
                      | {
                          type: 'mutate'
                          mutations: Mutation[]
                        }
                      | {
                          type: 'submit'
                        }
                      | {
                          type: 'xstate.done.actor.getDocument'
                          output: SanityDocument<DocumentType>
                        }
                      | {
                          type: 'xstate.done.actor.submitTransactions'
                          output: undefined
                        },
                      AnyEventObject
                    >
                  }) => {
                    client: SanityClient
                    transactions: Transaction[]
                  }
                  readonly onError: {
                    readonly target: 'submitFailure'
                  }
                  readonly onDone: {
                    readonly target: 'pristine'
                    readonly actions: readonly [
                      'restore stashed changes',
                      'reset submit attempts',
                      'send pristine event to parent',
                    ]
                  }
                }
                /**
                 * 'busy' means we should show a spinner, 'ready' means we can still accept mutations, they'll be applied optimistically right away, and queued for submissions after the current submission settles
                 */
                readonly tags: readonly ['busy', 'ready']
              }
              readonly submitFailure: {
                readonly exit: readonly ['clear error from context']
                readonly after: {
                  readonly submitTransactionsTimeout: {
                    readonly actions: readonly ['increment submit attempts']
                    readonly target: 'submitting'
                  }
                }
                readonly on: {
                  readonly retry: 'submitting'
                }
                /**
                 * How can it be both `ready` and `error`? `ready` means it can receive mutations, optimistically apply them, and queue them for submission. `error` means it failed to submit previously applied mutations.
                 * It's completely fine to keep queueing up more mutations and applying them optimistically, while showing UI that notifies that mutations didn't submit, and show a count down until the next automatic retry.
                 */
                readonly tags: readonly ['error', 'ready']
              }
            }
          }
          readonly loadFailure: {
            readonly exit: readonly ['clear error from context']
            readonly after: {
              readonly fetchRemoteSnapshotTimeout: {
                readonly actions: readonly ['increment fetch attempts']
                readonly target: 'loading'
              }
            }
            readonly on: {
              readonly retry: 'loading'
            }
            readonly tags: readonly ['error']
          }
        }
      }
    }
  }
>

export declare interface DocumentMutatorMachineInput {
  id: string
  client: SanityClient
  /** A shared listener can be provided, if not it'll be created using `client.listen()` */
  sharedListener?: ReturnType<typeof createSharedListener>
  cache?: Map<string, SanityDocument<DocumentType> | null>
}

export declare type DocumentMutatorMachineParentEvent =
  | {
      type: 'sync'
      id: string
      document: SanityDocumentBase
    }
  | {
      type: 'mutation'
      id: string
      effects: {
        apply: RawPatch
      }
      previousRev: string
      resultRev: string
    }
  | {
      type: 'rebased.local'
      id: string
      document: SanityDocumentBase
    }
  | {
      type: 'rebased.remote'
      id: string
      document: SanityDocumentBase
    }
  | {
      type: 'pristine'
      id: string
    }

export declare type ElementType<T extends AnyArray> =
  T extends AnyArray<infer E> ? E : unknown

export declare type Err<E> = Result<E, null>

export declare type FindBy<P, T extends AnyArray> = T extends AnyEmptyArray
  ? undefined
  : T[0] extends P
    ? T[0]
    : T extends [any, ...infer Tail] | readonly [any, ...infer Tail]
      ? FindBy<P, Tail>
      : ElementType<T>

export declare type FindInArray<
  P extends KeyedPathElement | number,
  T extends AnyArray,
> = P extends KeyedPathElement
  ? FindBy<P, T>
  : P extends number
    ? ByIndex<P, T>
    : never

export declare type Get<
  P extends number | KeyedPathElement | Readonly<KeyedPathElement> | string,
  T,
> = T extends AnyArray
  ? P extends KeyedPathElement | Readonly<KeyedPathElement> | number
    ? FindInArray<P, T>
    : undefined
  : P extends keyof T
    ? T[P]
    : never

export declare type GetAtPath<
  P extends readonly PathElement[],
  T,
> = P extends []
  ? T
  : P extends [infer Head, ...infer Tail]
    ? Head extends PathElement
      ? Tail extends PathElement[]
        ? GetAtPath<Tail, Get<Head, T>>
        : undefined
      : undefined
    : undefined

export declare function getAtPath<const Head extends PathElement, const T>(
  path: [head: Head],
  value: T,
): Get<Head, T>

export declare function getAtPath<
  const Head extends PathElement,
  const Tail extends PathElement[],
  T,
>(path: [head: Head, ...tail: Tail], value: T): GetAtPath<[Head, ...Tail], T>

export declare function getAtPath<T>(path: [], value: T): T

export declare function getAtPath(path: Path, value: unknown): unknown

export declare type IncOp<Amount extends number> = {
  type: 'inc'
  amount: Amount
}

export declare type Index = number

export declare type Insert = {
  before?: string
  after?: string
  replace?: string
  items: any[]
}

export declare type InsertOp<
  Items extends AnyArray,
  Pos extends RelativePosition,
  ReferenceItem extends Index | KeyedPathElement,
> = {
  type: 'insert'
  referenceItem: ReferenceItem
  position: Pos
  items: Items
}

export declare function isArrayElement(
  element: PathElement,
): element is KeyedPathElement | number

export declare function isElementEqual(
  segmentA: PathElement,
  segmentB: PathElement,
): boolean

export declare function isEqual(path: Path, otherPath: Path): boolean

export declare function isIndexElement(segment: PathElement): segment is number

export declare function isKeyedElement(
  element: PathElement,
): element is KeyedPathElement

export declare function isKeyElement(
  segment: PathElement,
): segment is KeyedPathElement

export declare function isPropertyElement(
  element: PathElement,
): element is string

export declare type KeyedPathElement = {
  _key: string
}

export declare type Merge<R extends Result<any, any>, E> = R[0] extends null
  ? Ok<R[1] & E>
  : R

export declare type MergeInner<
  R extends Result<any, any>,
  R2 extends Result<any, any>,
> = R2[0] extends null ? Merge<R, R2[1]> : R

export declare type Mutation<Doc extends SanityDocumentBase = any> =
  | CreateMutation<Doc>
  | CreateIfNotExistsMutation<Doc>
  | CreateOrReplaceMutation<Doc>
  | DeleteMutation
  | PatchMutation

export declare type MutationGroup =
  | NonTransactionalMutationGroup
  | TransactionalMutationGroup

export declare type NodePatch<
  P extends Path = Path,
  O extends Operation = Operation,
> = {
  path: P
  op: O
}

export declare type NodePatchList =
  | [NodePatch, ...NodePatch[]]
  | NodePatch[]
  | readonly NodePatch[]
  | readonly [NodePatch, ...NodePatch[]]

export declare interface NonTransactionalMutationGroup {
  transaction: false
  mutations: Mutation[]
}

export declare function normalize(path: string | Readonly<Path>): Readonly<Path>

export declare type NumberOp = IncOp<number> | DecOp<number>

export declare type ObjectOp = AssignOp | UnassignOp

export declare type Ok<V> = Result<null, V>

export declare type OnlyDigits<S> = S extends `${infer Head}${infer Tail}`
  ? Head extends Digit
    ? Tail extends ''
      ? true
      : OnlyDigits<Tail> extends true
        ? true
        : false
    : false
  : false

export declare type Operation = PrimitiveOp | ArrayOp | ObjectOp

export declare type Optional<T, K extends keyof T> = Omit<T, K> &
  Partial<Pick<T, K>>

export declare function parse<const T extends string>(path: T): StringToPath<T>

export declare type ParseAllProps<Props extends string[]> = Props extends [
  `${infer Head}`,
  ...infer Tail,
]
  ? Tail extends string[]
    ? ConcatInner<ParseProperty<Trim<Head>>, ParseAllProps<Tail>>
    : ParseProperty<Trim<Head>>
  : Ok<[]>

export declare type ParseError<T extends string = 'unknown'> = T & {
  error: true
}

export declare type ParseExpressions<S extends string> =
  S extends `[${infer Expr}]${infer Remainder}`
    ? Trim<Remainder> extends ''
      ? ToArray<ParseInnerExpression<Trim<Expr>>>
      : ConcatInner<
          ToArray<ParseInnerExpression<Trim<Expr>>>,
          ParseExpressions<Remainder>
        >
    : Err<ParseError<`Cannot parse object from "${S}"`>>

export declare type ParseInnerExpression<S extends string> = S extends ''
  ? Err<ParseError<'Saw an empty expression'>>
  : Try<ParseNumber<S>, ParseObject<S>>

export declare type ParseKVPair<S extends string> =
  Split<S, '=='> extends [`${infer LHS}`, `${infer RHS}`]
    ? ParseValue<Trim<RHS>> extends infer Res
      ? Res extends [null, infer Value]
        ? Ok<{
            [P in Trim<LHS>]: Value
          }>
        : Err<
            ParseError<`Can't parse right hand side as a value in "${S}" (Invalid value ${RHS})`>
          >
      : never
    : Err<ParseError<`Can't parse key value pair from ${S}`>>

export declare type ParseNumber<S extends string> =
  S extends `${infer Head}${infer Tail}`
    ? Head extends '-'
      ? OnlyDigits<Tail> extends true
        ? Ok<ToNumber<S>>
        : Err<ParseError<`Invalid integer value "${S}"`>>
      : OnlyDigits<S> extends true
        ? Ok<ToNumber<S>>
        : Err<ParseError<`Invalid integer value "${S}"`>>
    : Err<ParseError<`Invalid integer value "${S}"`>>

export declare type ParseObject<S extends string> =
  S extends `${infer Pair},${infer Remainder}`
    ? Trim<Remainder> extends ''
      ? Ok<Record<never, never>>
      : MergeInner<ParseKVPair<Pair>, ParseObject<Remainder>>
    : ParseKVPair<S>

export declare type ParseProperty<S extends string> =
  Trim<S> extends ''
    ? Err<ParseError<'Empty property'>>
    : Split<Trim<S>, '[', true> extends [`${infer Prop}`, `${infer Expression}`]
      ? Trim<Prop> extends ''
        ? ParseExpressions<Trim<Expression>>
        : ConcatInner<Ok<[Trim<Prop>]>, ParseExpressions<Trim<Expression>>>
      : Ok<[Trim<S>]>

export declare type ParseValue<S extends string> = string extends S
  ? Err<ParseError<'ParseValue got generic string type'>>
  : S extends 'null'
    ? Ok<null>
    : S extends 'true'
      ? Ok<true>
      : S extends 'false'
        ? Ok<false>
        : S extends `"${infer Value}"`
          ? Ok<Value>
          : Try<
              ParseNumber<S>,
              Err<
                ParseError<`ParseValue failed. Can't parse "${S}" as a value.`>
              >
            >

export declare type PatchMutation<
  Patches extends NodePatchList = NodePatchList,
> = {
  type: 'patch'
  id: string
  patches: Patches
  options?: PatchOptions
}

export declare type PatchOptions = {
  ifRevision?: string
}

export declare type Path = PathElement[] | readonly PathElement[]

export declare type PathElement = PropertyName | Index | KeyedPathElement

export declare type PrimitiveOp = AnyOp | StringOp | NumberOp

export declare type PropertyName = string

export declare type RawOperation = any

export declare type RawPatch = RawOperation[]

export declare function rebase(
  documentId: string,
  oldBase: SanityDocumentBase | undefined,
  newBase: SanityDocumentBase | undefined,
  stagedMutations: MutationGroup[],
): [newStage: MutationGroup[], rebased: SanityDocumentBase | undefined]

export declare type RelativePosition = 'before' | 'after'

export declare type RemoveOp<ReferenceItem extends Index | KeyedPathElement> = {
  type: 'remove'
  referenceItem: ReferenceItem
}

export declare type ReplaceOp<
  Items extends AnyArray,
  ReferenceItem extends Index | KeyedPathElement,
> = {
  type: 'replace'
  referenceItem: ReferenceItem
  items: Items
}

export declare type Result<E, V> = [E, V]

export declare type SafePath<S extends string> = StripError<StringToPath<S>>

export declare type SanityCreateIfNotExistsMutation<
  Doc extends SanityDocumentBase,
> = {
  createIfNotExists: Doc
}

export declare type SanityCreateMutation<Doc extends SanityDocumentBase> = {
  create: Doc
}

export declare type SanityCreateOrReplaceMutation<
  Doc extends SanityDocumentBase,
> = {
  createOrReplace: Doc
}

export declare type SanityDeleteMutation = {
  delete: {
    id: string
  }
}

export declare type SanityDiffMatchPatch = {
  id: string
  diffMatchPatch: {
    [path: string]: string
  }
}

export declare type SanityDocumentBase = {
  _id?: string
  _type: string
  _createdAt?: string
  _updatedAt?: string
  _rev?: string
}

export declare type SanityInsertPatch = {
  id: string
  insert: Insert
}

export declare type SanityMutation<
  Doc extends SanityDocumentBase = SanityDocumentBase,
> =
  | SanityCreateMutation<Doc>
  | SanityCreateIfNotExistsMutation<Doc>
  | SanityCreateOrReplaceMutation<Doc>
  | SanityDeleteMutation
  | SanityPatchMutation

export declare type SanityMutationEvent = {
  type: 'mutation'
  documentId: string
  eventId: string
  identity: string
  mutations: SanityMutation[]
  previousRev?: string
  resultRev?: string
  result?: SanityDocumentBase
  previous?: SanityDocumentBase | null
  effects?: {
    apply: RawPatch
  }
  timestamp: string
  transactionId: string
  transition: 'update' | 'appear' | 'disappear'
  visibility: 'query' | 'transaction'
}

export declare type SanityPatchMutation = {
  patch:
    | SanitySetPatch
    | SanitySetIfMissingPatch
    | SanityDiffMatchPatch
    | SanityInsertPatch
    | SanityUnsetPatch
}

export declare type SanitySetIfMissingPatch = {
  id: string
  setIfMissing: {
    [path: string]: any
  }
}

export declare type SanitySetPatch = {
  id: string
  set: {
    [path: string]: any
  }
}

export declare type SanityUnsetPatch = {
  id: string
  unset: string[]
}

export declare type SetIfMissingOp<T> = {
  type: 'setIfMissing'
  value: T
}

export declare type SetOp<T> = {
  type: 'set'
  value: T
}

export declare type SharedListenerEvents = ObservedValueOf<
  ReturnType<typeof createSharedListener>
>

export declare type Split<
  S extends string,
  Char extends string,
  IncludeSeparator extends boolean = false,
> = S extends `${infer First}${Char}${infer Remainder}`
  ? [First, `${IncludeSeparator extends true ? Char : ''}${Remainder}`]
  : [S]

export declare type SplitAll<
  S extends string,
  Char extends string,
> = S extends `${infer First}${Char}${infer Remainder}`
  ? [First, ...SplitAll<Remainder, Char>]
  : [S]

export declare function squashDMPStrings(
  remote: DataStore,
  mutationGroups: MutationGroup[],
): MutationGroup[]

export declare function squashMutationGroups(
  staged: MutationGroup[],
): MutationGroup[]

export declare function startsWith(parentPath: Path, path: Path): boolean

export declare function stringify(pathArray: Path): string

export declare type StringOp = DiffMatchPatchOp

export declare type StringToPath<S extends string> = Unwrap<
  ParseAllProps<SplitAll<Trim<S>, '.'>>
>

export declare type StripError<
  S extends StringToPath<string> | ParseError<string>,
> = S extends ParseError<string> ? never : S

export declare type ToArray<R extends Result<any, any>> = R extends [
  infer E,
  infer V,
]
  ? E extends null
    ? V extends any[]
      ? R
      : Ok<[R[1]]>
    : R
  : R

export declare type ToNumber<T extends string> =
  T extends `${infer N extends number}` ? N : never

export declare function toTransactions(groups: MutationGroup[]): Transaction[]

export declare interface Transaction {
  id?: string
  mutations: Mutation[]
}

export declare interface TransactionalMutationGroup {
  transaction: true
  id?: string
  mutations: Mutation[]
}

export declare type Trim<
  S extends string,
  Char extends string = ' ',
> = TrimRight<TrimLeft<S, Char>, Char>

export declare type TrimLeft<
  Str extends string,
  Char extends string = ' ',
> = string extends Str
  ? Str
  : Str extends `${Char}${infer Trimmed}`
    ? TrimLeft<Trimmed, Char>
    : Str

export declare type TrimRight<
  Str extends string,
  Char extends string = ' ',
> = string extends Str
  ? Str
  : Str extends `${infer Trimmed}${Char}`
    ? TrimRight<Trimmed, Char>
    : Str

export declare type TruncateOp = {
  type: 'truncate'
  startIndex: number
  endIndex?: number
}

export declare type Try<R extends Result<any, any>, Handled> = R[1] extends null
  ? Handled
  : R

export declare type UnassignOp<
  K extends readonly string[] = readonly string[],
> = {
  type: 'unassign'
  keys: K
}

export declare type UnsetOp = {
  type: 'unset'
}

export declare type Unwrap<R extends Result<any, any>> = R extends [
  infer E,
  infer V,
]
  ? E extends null
    ? V
    : E
  : never

export declare interface UpdateResult<T extends SanityDocumentBase> {
  id: string
  status: 'created' | 'updated' | 'deleted'
  before?: T
  after?: T
  mutations: Mutation[]
}

export declare type UpsertOp<
  Items extends AnyArray,
  Pos extends RelativePosition,
  ReferenceItem extends Index | KeyedPathElement,
> = {
  type: 'upsert'
  items: Items
  referenceItem: ReferenceItem
  position: Pos
}

export {}
