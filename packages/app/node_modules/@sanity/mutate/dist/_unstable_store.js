import { finalize, share, ReplaySubject, timer, Subject, merge, map, EMPTY, lastValueFrom, toArray, defer, filter, mergeMap, of, tap } from "rxjs";
import { decodeAll } from "./_chunks-es/decode.js";
import { applyPatch } from "mendoza";
import { getMutationDocumentId, applyMutations, commit, squashMutationGroups, toTransactions, squashDMPStrings, rebase } from "./_chunks-es/toTransactions.js";
function omitRev(document) {
  if (document === void 0)
    return;
  const { _rev, ...doc } = document;
  return doc;
}
function applyMendozaPatch(document, patch, patchBaseRev) {
  if (patchBaseRev !== document?._rev)
    throw new Error(
      "Invalid document revision. The provided patch is calculated from a different revision than the current document"
    );
  const next = applyPatch(omitRev(document), patch);
  return next === null ? void 0 : next;
}
function applyMutationEventEffects(document, event) {
  if (!event.effects)
    throw new Error(
      "Mutation event is missing effects. Is the listener set up with effectFormat=mendoza?"
    );
  const next = applyMendozaPatch(
    document,
    event.effects.apply,
    event.previousRev
  );
  return next ? { ...next, _rev: event.resultRev } : void 0;
}
function createDataset() {
  const documents = /* @__PURE__ */ new Map();
  return {
    set: (id, doc) => void documents.set(id, doc),
    get: (id) => documents.get(id),
    delete: (id) => documents.delete(id)
  };
}
function createReplayMemoizer(expiry) {
  const memo = /* @__PURE__ */ Object.create(null);
  return function(key, observable) {
    return key in memo || (memo[key] = observable.pipe(
      finalize(() => {
        delete memo[key];
      }),
      share({
        connector: () => new ReplaySubject(1),
        resetOnRefCountZero: () => timer(expiry)
      })
    )), memo[key];
  };
}
function filterMutationGroupsById(mutationGroups, id) {
  return mutationGroups.flatMap(
    (mutationGroup) => mutationGroup.mutations.flatMap(
      (mut) => getMutationDocumentId(mut) === id ? [mut] : []
    )
  );
}
let didEmitMutationsAccessWarning = !1;
function warnNoMutationsReceived() {
  didEmitMutationsAccessWarning || (console.warn(
    new Error(
      "No mutation received from backend. The listener is likely set up with `excludeMutations: true`. If your app need to now about mutations, make sure the listener is set up to include mutations"
    )
  ), didEmitMutationsAccessWarning = !0);
}
const EMPTY_ARRAY = [];
function createContentLakeStore(backend) {
  const local = createDataset(), remote = createDataset(), memoize = createReplayMemoizer(1e3);
  let stagedChanges = [];
  const remoteEvents$ = new Subject(), localMutations$ = new Subject(), stage$ = new Subject();
  function stage(nextPending) {
    stagedChanges = nextPending, stage$.next();
  }
  function getLocalEvents(id) {
    return localMutations$.pipe(filter((event) => event.id === id));
  }
  function getRemoteEvents(id) {
    return backend.observe(id).pipe(
      filter(
        (event) => event.type !== "reconnect"
      ),
      mergeMap((event) => {
        const oldLocal = local.get(id), oldRemote = remote.get(id);
        if (event.type === "sync") {
          const newRemote = event.document, [rebasedStage, newLocal] = rebase(
            id,
            oldRemote,
            newRemote,
            stagedChanges
          );
          return of({
            type: "sync",
            id,
            before: { remote: oldRemote, local: oldLocal },
            after: { remote: newRemote, local: newLocal },
            rebasedStage
          });
        } else if (event.type === "mutation") {
          if (event.transactionId === oldRemote?._rev)
            return EMPTY;
          const newRemote = applyMutationEventEffects(oldRemote, event), [rebasedStage, newLocal] = rebase(
            id,
            oldRemote,
            newRemote,
            stagedChanges
          );
          newLocal && (newLocal._rev = event.transactionId);
          const emittedEvent = {
            type: "mutation",
            id,
            rebasedStage,
            before: { remote: oldRemote, local: oldLocal },
            after: { remote: newRemote, local: newLocal },
            effects: event.effects,
            previousRev: event.previousRev,
            resultRev: event.resultRev,
            // overwritten below
            mutations: EMPTY_ARRAY
          };
          return event.mutations ? emittedEvent.mutations = decodeAll(
            event.mutations
          ) : Object.defineProperty(
            emittedEvent,
            "mutations",
            warnNoMutationsReceived
          ), of(emittedEvent);
        } else
          throw new Error(`Unknown event type: ${event.type}`);
      }),
      tap((event) => {
        local.set(event.id, event.after.local), remote.set(event.id, event.after.remote), stage(event.rebasedStage);
      }),
      tap({
        next: (event) => remoteEvents$.next(event),
        error: (err) => {
        }
      })
    );
  }
  function observeEvents(id) {
    return defer(
      () => memoize(id, merge(getLocalEvents(id), getRemoteEvents(id)))
    );
  }
  return {
    meta: {
      events: merge(localMutations$, remoteEvents$),
      stage: stage$.pipe(
        map(
          () => (
            // note: this should not be tampered with by consumers. We might want to do a deep-freeze during dev to avoid accidental mutations
            stagedChanges
          )
        )
      ),
      conflicts: EMPTY
      // does nothing for now
    },
    mutate: (mutations) => {
      stagedChanges.push({ transaction: !1, mutations });
      const results = applyMutations(mutations, local);
      return commit(results, local), results.forEach((result) => {
        localMutations$.next({
          type: "optimistic",
          before: result.before,
          after: result.after,
          mutations: result.mutations,
          id: result.id,
          stagedChanges: filterMutationGroupsById(stagedChanges, result.id)
        });
      }), results;
    },
    transaction: (mutationsOrTransaction) => {
      const transaction = Array.isArray(
        mutationsOrTransaction
      ) ? { mutations: mutationsOrTransaction, transaction: !0 } : { ...mutationsOrTransaction, transaction: !0 };
      stagedChanges.push(transaction);
      const results = applyMutations(transaction.mutations, local);
      return commit(results, local), results.forEach((result) => {
        localMutations$.next({
          type: "optimistic",
          mutations: result.mutations,
          id: result.id,
          before: result.before,
          after: result.after,
          stagedChanges: filterMutationGroupsById(stagedChanges, result.id)
        });
      }), results;
    },
    observeEvents,
    observe: (id) => observeEvents(id).pipe(
      map(
        (event) => event.type === "optimistic" ? event.after : event.after.local
      )
    ),
    optimize: () => {
      stage(squashMutationGroups(stagedChanges));
    },
    submit: () => {
      const pending = stagedChanges;
      return stage([]), lastValueFrom(
        backend.submit(
          toTransactions(
            // Squashing DMP strings is the last thing we do before submitting
            squashDMPStrings(remote, squashMutationGroups(pending))
          )
        ).pipe(toArray())
      );
    }
  };
}
export {
  createContentLakeStore
};
//# sourceMappingURL=_unstable_store.js.map
